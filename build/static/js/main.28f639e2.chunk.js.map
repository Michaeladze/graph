{"version":3,"sources":["Graph/LayeredGraph/connectedness.ts","Graph/LayeredGraph/ranking.ts","Graph/LayeredGraph/rearrangeMatrix.ts","Graph/LayeredGraph/fillGaps.ts","Graph/LayeredGraph/ordering.ts","Graph/LayeredGraph/insertFakeNodes.ts","Graph/LayeredGraph/balancing.ts","Graph/LayeredGraph/drawEdges.ts","Graph/LayeredGraph/translateFakeNodes.ts","Graph/LayeredGraph/index.ts","Graph/LayeredGraph/createGraph.ts","Graph/LayeredGraph/detectStartEnd.ts","Graph/LayeredGraph/createNodes.ts","Graph/LayeredGraph/shrinkFakeNodes.ts","Graph/LayeredGraph/stickToLeft.ts","Graph/GraphNode/GraphNode.tsx","Graph/Graph/index.ts","Graph/Graph/Graph.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["connectedness","process","graph","visited","Object","keys","forEach","n","dfs","node","parent","processSibling","children","ranking","paths","entries","filter","a","isProcess","sort","b","e","mRank","relativesCount","parents","type","y","Math","ceil","isNaN","arrangeRanks","processGraph","Array","from","Set","rankY","setProcessRank","matrix","endIndex","findIndex","push","splice","map","Map","item","currentY","idx","size","has","get","set","length","undefined","normalize","rearrangeMatrix","key","x","fillGaps","median","i","undefinedQueue","j","fake","c","shift","ordering","end","rank","indexOf","rankNodes","child","index","relatives","processNode","find","startShiftingRank","name","shiftRanks","findParentChild","insertFakeNodes","edges","processList","indexesToRemove","pathMap","e1","e2","abs","to","edge","delta","pathName","result","path","add","insertedNodeIndex","includes","desiredX","n1","n2","max","columnIsEmpty","findDesiredX","fromNode","hashNodeName","insertNode","insertFakeNode","indexes","m","zeros","s","fill","join","row","col","css","appendToProcess","balancing","ptm","maxLengthRank","left","right","leftRealNodes","rightRealNodes","ratio","floor","realRatio","checkBalance","processToMedian","branches","acc","bfs","stack","pop","values","reduce","branch","split","s1","s2","searchBranches","processedPaths","processedNodes","averageXCache","recursiveBalancing","pathToMove","approximations","p","realNodes","avgX","round","getBranchAverageX","a1","a2","pathsCount","cb","processedCount","realNodesCount","shifted","shiftToLeft","drawEdges","scene","config","lines","svgElement","querySelector","removeChild","maxX","Number","MIN_SAFE_INTEGER","v","translate","scrollWidth","svg","d3","append","attr","scrollHeight","rect","coords","metricsCoords","calculateCoords","metricInserted","id","reverseId","mid","first","last","deltaX","deltaY","width","height","points","getCoords","curve","l","d","disabled","status","pathElement","drawPath","colors","toPath","style","_groups","appendOverlayRect","intersection","intersect","getAttribute","remove","line","color","default","primary","hover","marker","markers","createMarker","count","metrics","text","insertMetrics","lineGenerator","LayeredGraph","data","start","gap","fakeWidth","this","nodes","JSON","parse","createGraph","startEnd","toLowerCase","detectStartEnd","fakes","balance","tfn","leftPaths","rightPaths","array","every","leftEntries","rightEntries","valid","MAX_SAFE_INTEGER","min","translateFakeNodes","cycling","mCycling","isCyclingOk","createNodes","shrinkFakeNodes","minX","stickToLeft","console","log","GraphNode","cyclingClass","className","Graph","useRef","useState","setGraph","setNodes","currentCoords","top","useEffect","current","init","dragging","draggingNode","onMouseDown","currentTarget","onMouseUp","onMouseMove","stopPropagation","clientX","offsetWidth","clientY","offsetHeight","transform","window","addEventListener","removeEventListener","onMouseEnter","el","stroke","setAttribute","onMouseLeave","nodesJSX","ref","App","GRAPH_DATA","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"uTAMaA,EAAgB,SAACC,EAAiBC,GAC7C,IAAMC,EAA2C,GAkCjDC,OAAOC,KAAKH,GAAOI,SAAQ,SAACC,IAhChB,SAANC,EAAOC,EAAcC,GACpBP,EAAQM,KACXN,EAAQM,GAAQ,IAGH,OAAXC,IACFP,EAAQM,GAAMC,IAAU,EAEpBT,EAAQQ,KAAUR,EAAQS,KAC5BR,EAAMQ,GAAQC,eAAiB,IAG5BV,EAAQQ,IAASR,EAAQS,KAC5BR,EAAMO,GAAME,eAAiB,GAG1BV,EAAQQ,IAAUR,EAAQS,KAC7BR,EAAMO,GAAME,eAAiBT,EAAMQ,GAAQC,eAAiB,IAIhET,EAAMO,GAAMG,SAASN,SAAQ,SAACC,GACvBJ,EAAQI,KACXJ,EAAQI,GAAK,IAGVL,EAAMK,GAAGI,gBAAmBR,EAAQI,GAAGE,IAC1CD,EAAID,EAAGE,MAMXD,EAAKD,EAAG,UCxBCM,EAAU,SAAC,EAAuBX,EAAeD,GAA+B,EAAnEa,MAKxB,OAsCF,SAAsBb,EAAiBC,GAErCF,EAAcC,EAASC,GAGGE,OAAOW,QAAQb,GACtCc,QAAO,SAACC,GAAD,OAAgBf,GAAOe,EAAE,IAAIC,aACpCC,MAAK,SAACF,EAAWG,GAAZ,OAA0BH,EAAE,GAAGN,eAAiBS,EAAE,GAAGT,kBAErDL,SAAQ,SAACe,GAEf,IAAIC,EAAQ,EAERC,EAAyB,EAI7B,sBAAIF,EAAE,GAAGT,UAAT,YAAsBS,EAAE,GAAGG,UAASlB,SAAQ,SAACC,GACrB,QAAlBL,EAAMK,GAAGkB,OACXH,GAASpB,EAAMK,GAAGmB,GAEjBxB,EAAMK,GAAGW,WAAahB,EAAMK,GAAGmB,IAAMH,QAK1C,IAAMG,EAAYC,KAAKC,KAAKN,EAAQC,GAAkB,EACtDF,EAAE,GAAGK,EAAIG,MAAMH,GAAK,EAAIA,KAnE1BI,CAWF,SAAwB7B,EAAmBC,GACzC,IAAM6B,EAAuB,GAQ7B,OALAC,MAAMC,KAAK,IAAIC,IAAIjC,IAAUK,SAAQ,SAACG,EAAc0B,GAClDjC,EAAMO,GAAMiB,EAAIS,EAAQ,EACxBjC,EAAMO,GAAMS,UAAY,EACxBa,EAAatB,GAAQP,EAAMO,MAEtBsB,EArBsBK,CAAenC,EAASC,GAC1BA,GAyE7B,SAAmBA,GAEjB,IAAMmC,EAAkB,GAGlBtB,EAAoBX,OAAOW,QAAQb,GAAOiB,MAC9C,SAACF,EAAWG,GAAZ,OAA0BA,EAAE,GAAGF,UAAYD,EAAE,GAAGC,WAAaD,EAAE,GAAGS,EAAIN,EAAE,GAAGM,KAIvEY,EAAmBvB,EAAQwB,WAAU,SAAClB,GAAD,MAA6B,QAAdA,EAAE,GAAGI,QAC/DV,EAAQyB,KAAKzB,EAAQuB,IACrBvB,EAAQ0B,OAAOH,EAAU,GAIzB,IAAMI,EAAM,IAAIC,IAoBhB,OAhBA5B,EAAQT,SAAQ,SAACsC,GAEf,IAAMC,EAAmBD,EAAK,GAAGlB,EAE7BoB,EAAcJ,EAAIK,KAErBL,EAAIM,IAAIH,GAAsCC,EAAMJ,EAAIO,IAAIJ,GAAxCH,EAAIQ,IAAIL,EAAUC,IAEtCT,EAAOS,KAAST,EAAOS,GAAO,KAE9BF,EAAK,GAAG1B,YAAcmB,EAAOS,GAAKK,QAAUd,EAAOS,GAAKN,UAAKY,GAE9Df,EAAOS,GAAKN,MAAMI,EAAK,IACvB1C,GAAO0C,EAAK,IAAIlB,EAAIgB,EAAIO,IAAIJ,MAGvBR,EA5GEgB,CAAUnD,ICjBd,IAAMoD,EAAkB,SAACpD,GAC9B,IAAMmC,EAAkB,GAExB,IAAK,IAAMkB,KAAOrD,OACakD,IAAzBf,EAAOnC,EAAMqD,GAAK7B,KACpBW,EAAOnC,EAAMqD,GAAK7B,GAAK,IAGzBW,EAAOnC,EAAMqD,GAAK7B,GAAGxB,EAAMqD,GAAKC,IAAMD,EAGxC,OAAOlB,GCZIoB,EAAW,SAACvD,GAIvB,IAJuE,IAAjCwD,EAAgC,uDAAf,EACnDrB,EAAkBiB,EAAgBpD,GAG7ByD,EAAY,EAAGA,EAAItB,EAAOc,OAAQQ,IAIzC,IAFA,IAAIC,EAA2B,GAEtBC,EAAYH,EAAQG,EAAIxB,EAAOsB,GAAGR,OAAQU,IACjD,QAAqBT,IAAjBf,EAAOsB,GAAGE,GAEZD,EAAepB,KAAKqB,OACf,CACL,GAAI3D,EAAMmC,EAAOsB,GAAGE,IAAcC,KAChC,SAGF,IAAMC,EAAwBH,EAAeI,QACzCD,IAEF7D,EAAMmC,EAAOsB,GAAGE,IAAcL,EAAIO,EAClC1B,EAAOsB,GAAGI,GAAK1B,EAAO,GAAGwB,GACzBxB,EAAOsB,GAAGE,QAAKT,EACfQ,EAAepB,KAAKqB,IAM5B,OAAOxB,GCnBI4B,EAAW,SAAC/D,EAAemC,EAAiB6B,GAEvD,IAAK,IAAMX,KAAOrD,EAChB,IAAKA,EAAMqD,GAAKrC,UAAW,CACzB,IAAMiD,EAAejE,EAAMqD,GAAK7B,EAChCxB,EAAMqD,GAAKC,EAAInB,EAAO8B,GAAMC,SAASb,GAYzC,OAPIlB,EAAOA,EAAOc,OAAS,GAAGA,OAAS,IACrCjD,EAAMgE,GAAKxC,EAAIW,EAAOc,QAIxBd,EAQF,SAAyBnC,EAAemC,GAEtC,IAFiE,IAAD,WAEvD8B,GACP,IAAME,EAAsBhC,EAAO8B,GAG/BE,GACFA,EAAU/D,SAAQ,SAACG,GACjBP,EAAMO,GAAgBG,SAASN,SAAQ,SAACgE,GACtC,IAAMC,EAAgBF,EAAUD,QAAQE,GAEpCC,GAAS,GAAK9D,IAAS4D,EAAUE,MAqB/C,SAAoBJ,EAAczD,EAAgB4D,EAAepE,EAAemC,GAE9E,IAAMtB,EAAoBX,OAAOW,QAAQb,GAAOiB,MAAK,SAACF,EAAWG,GAAZ,OAA0BH,EAAE,GAAGS,EAAIN,EAAE,GAAGM,KAGvF8C,EAAmB,sBAAOtE,EAAMoE,GAAO1D,UAApB,YAAiCV,EAAMoE,GAAO9C,UAEjEiD,EAAsB1D,EAAQ2D,MAClC,gBAAErD,EAAF,2BAAiBnB,GAAOmB,EAAE,IAAIK,IAAMyC,EAAO,GAAKjE,GAAOmB,EAAE,IAAIH,aAI3DyD,EAA4BR,GAI7BM,GAAeD,EAAUJ,SAASK,EAAY,KAAO,QAA4CrB,IAAtCf,EAAO8B,EAAO,GAAGjE,EAAMQ,GAAQ8C,MAE3FmB,EAAoBR,EAAO,GAIzBQ,EAAoBR,GACtBpD,EAAQT,SAAQ,SAACe,GACf,IAAMuD,GAAgBvD,EAAE,GAGpBA,EAAE,GAAGK,GAAKiD,IACZzE,EAAM0E,GAAMlD,GAAK,MAMlBxB,EAAMoE,GAAOpD,WAAchB,EAAMQ,GAAQQ,YAC5ChB,EAAMoE,GAAOd,EAAItD,EAAMQ,GAAQ8C,GAEjCtD,EAAMoE,GAAO5C,EAAIxB,EAAMQ,GAAQgB,EAAI,EAxDzBmD,CAAWV,EAAM1D,EAAgB4D,EAAUE,GAAkBrE,EAAOmC,GAEpEA,EAASiB,EAAgBpD,WAb1BiE,EAAe,EAAGA,EAAO9B,EAAOc,OAAQgB,IAAS,EAAjDA,GAoBT,OAAO9B,EA9BEyC,CAAgB5E,EAAOoD,EAAgBpD,IAEzCuD,EAASvD,I,WCbL6E,EAAkB,SAACC,EAAgB9E,EAAemC,EAAiB4C,GAE9E,IAAMhF,EAAiB,YAAOgF,GAE1BC,EAA+B,IAAIhD,IAEjCiD,EAAoB,GAG1BH,EACG7D,MAAK,SAACiE,EAAWC,GAGhB,OAFuB1D,KAAK2D,IAAIpF,EAAMkF,EAAGnD,MAAMP,EAAIxB,EAAMkF,EAAGG,IAAI7D,GACzCC,KAAK2D,IAAIpF,EAAMmF,EAAGpD,MAAMP,EAAIxB,EAAMmF,EAAGE,IAAI7D,MAGjEpB,SAAQ,SAACkF,EAAa7B,GACrB,IAAI8B,EAAgBvF,EAAMsF,EAAKvD,MAAMP,EAAIxB,EAAMsF,EAAKD,IAAI7D,EACxD,GAAIC,KAAK2D,IAAIG,GAAS,EAAG,CAEvB,IAAMC,EAAgB,UAAMF,EAAKvD,KAAX,aAAoBuD,EAAKD,IAE1CJ,EAAQO,KACXP,EAAQO,GAAY,IAAIxD,KAI1B,IAAMyD,EAwCd,SACE1D,EACAsD,EACArF,EACA8E,EACArB,EACAtB,EACAoD,EACAP,EACAU,EACA3F,GAMAiF,EAAgBW,IAAIlC,GAGU,IAA1BzD,EAAM+B,GAAMf,WAAiB0E,EAAKC,IAAI5D,GACd,IAAxB/B,EAAMqF,GAAIrE,WAAiB0E,EAAKC,IAAIN,GAGxC,IAAIO,GAA6B,EAG3B5E,EAAqBjB,EACxByC,KAAI,SAACnC,EAAWoD,GAAZ,gBAA6BpD,EAA7B,aAAmCN,EAAQ0D,EAAI,OACnDoC,SAFwB,UAEZ9D,EAFY,aAEHsD,IAGlBS,EAkHR,SAAsB/D,EAAcsD,EAAYrF,EAAemC,GAC7D,IAAM4D,EAAiB/F,EAAM+B,GACvBiE,EAAiBhG,EAAMqF,GAEvBxB,EAAakC,EAAGvE,EAAIwE,EAAGxE,EAGzBA,EAAYqC,EAAIkC,EAAGvE,EAAI,EAAIuE,EAAGvE,EAAI,EAGlC8B,EAAY7B,KAAKwE,IAAIF,EAAGzC,EAAG0C,EAAG1C,GAIlC,OAAa,CAEX,IADA,IAAI4C,GAAyB,EACrBrC,EAAIrC,EAAIwE,EAAGxE,EAAIA,EAAIwE,EAAGxE,EAAGqC,EAAIrC,IAAMA,IACzC,QAAqB0B,IAAjBf,EAAOX,GAAG8B,GAAkB,CAC9B4C,GAAgB,EAChB,MAIJ,GAAIA,EACF,MAGF5C,IAGF,OAAOA,EAhJkB6C,CAAapE,EAAMsD,EAAIrF,EAAOmC,GAGjD4D,EAAiB/F,EAAM+B,GACvBiE,EAAiBhG,EAAMqF,GACvBxB,EAAakC,EAAGvE,EAAIwE,EAAGxE,EACzBA,EAAYqC,EAAIkC,EAAGvE,EAAI,EAAIuE,EAAGvE,EAAI,EAGlC4E,EAAmBrE,EAEvB,KAAQ8B,EAAIrC,EAAIwE,EAAGxE,EAAIA,EAAIwE,EAAGxE,EAAGqC,EAAIrC,IAAMA,IAAK,CAE9C,IAAMkD,EAAe2B,EAAatE,EAAMsD,EAAI7D,GAC5CkE,EAAKC,IAAIjB,GAETkB,EAAoBU,EAAWtG,EAAO8E,EAAOJ,EAAMlD,EAAGsE,EAAUM,EAAUf,EAAIrE,EAAWjB,GACzFiF,EAAgBW,IAAIC,GACpBQ,EAAW1B,EAGb,MAAO,CACLM,kBACA7C,OAAQiB,EAAgBpD,IA9FLuG,CACbjB,EAAKvD,KACLuD,EAAKD,GACLrF,EACA8E,EACArB,EACAtB,EACAoD,EACAP,EACAC,EAAQO,GACRzF,GAGFiF,EAAkBS,EAAOT,gBACzB7C,EAASsD,EAAOtD,WAOtB,IAFA,IAAMqE,EAAoB1E,MAAMC,KAAKiD,GAAiB/D,MAAK,SAACZ,EAAWoG,GAAZ,OAA0BpG,EAAIoG,KAEhFhD,EAAY+C,EAAQvD,OAAS,EAAGQ,GAAK,EAAGA,IAC/CqB,EAAMvC,OAAOiE,EAAQ/C,GAAI,GAG3B,MAAO,CAAEqB,QAAOG,UAASlF,YA8E3B,SAASsG,EAAatE,EAAcsD,EAAYqB,GAC9C,IAAMC,EAAY,IAAI7E,MAAM4E,GAAOE,KAAK,KAAKC,KAAK,IAClD,OAAQpF,KAAK2D,KAAK,GAAD,OAAIC,GAAJ,OAASsB,GAAT,OAAa5E,IAchC,SAASuE,EACPtG,EACA8E,EACAJ,EACAoC,EACAC,EACAhF,EACAsD,EACArE,EACAjB,GAyCA,OAtCAC,EAAM0E,GAAQ,CACZhE,SAAU,CAAC2E,GACX/B,EAAGyD,EACHvF,EAAGsF,EACHxF,QAAS,CAACS,GACVf,UAAWA,EAAY,EAAI,EAC3BP,eAAgB,EAChBmD,KAAM,EACNoD,IAAK,IAGHhG,GAmCN,SAAyBqE,EAAY9E,EAAcR,GACjD,IAAMsE,EAAgBtE,EAAQmE,QAAQmB,GAClChB,GAAS,GACXtE,EAAQwC,OAAO8B,EAAO,EAAG9D,GApCzB0G,CAAgB5B,EAAIX,EAAM3E,GAI5BC,EAAM+B,GAAN,eACK/B,EAAM+B,GADX,CAEErB,SAAS,GAAD,mBAAMV,EAAM+B,GAAMrB,SAASI,QAAO,SAACT,GAAD,OAAeA,IAAMgF,MAAvD,CAA4DX,MAItE1E,EAAMqF,GAAN,eACKrF,EAAMqF,GADX,CAEE/D,QAAQ,GAAD,mBAAMtB,EAAMqF,GAAI/D,QAAQR,QAAO,SAACT,GAAD,OAAeA,IAAM0B,MAApD,CAA2D2C,MAIpEI,EAAMxC,KAAK,CACTP,KAAMA,EACNsD,GAAIX,IAENI,EAAMxC,KAAK,CACTP,KAAM2C,EACNW,GAAIA,IAGCP,EAAM7B,OAAS,E,YC1LXiE,EAAY,SAACnH,EAAmBC,EAAemC,GAE1D,IAAIgF,EA2EN,SAAyBnH,EAAemC,GACtC,IAAIiF,EAAwB,EAC5BjF,EAAO/B,SAAQ,SAAC6D,GACdmD,EAAgB3F,KAAKwE,IAAIhC,EAAKhB,OAAQmE,MAIxC,IAAM5D,EAAiB4D,EAGvB,IAAK,IAAM/D,KAAOrD,EAChBA,EAAMqD,GAAKC,EAAItD,EAAMqD,GAAKC,EAAIE,EAXsC,MA2BxE,SAAsBrB,EAAiBqB,EAAgBxD,GAQrD,IAPA,IAAIqH,EAAe,EACfC,EAAgB,EAGhBC,EAAwB,EACxBC,EAAyB,EAEpB/D,EAAY,EAAGA,EAAItB,EAAOc,OAAQQ,IACzC,IAAK,IAAIE,EAAY,EAAGA,EAAIxB,EAAOsB,GAAGR,OAAQU,IACxCA,IAAMH,IAMNrB,EAAOsB,GAAGE,IAAMA,EAAIH,IACtB6D,IACKrH,EAAMmC,EAAOsB,GAAGE,IAAcC,MACjC2D,KAGApF,EAAOsB,GAAGE,IAAMA,EAAIH,IACtB8D,IACKtH,EAAMmC,EAAOsB,GAAGE,IAAcC,MACjC4D,MAMR,IAAMC,EAAgBhG,KAAKiG,OAAOJ,EAAQD,GAAQ,GAC5CM,EAAoBlG,KAAKiG,OAAOF,EAAiBD,GAAiB,GAGxE,MAAO,CAAEE,QAAOE,aA5C4BC,CAH5CzF,EAASiB,EAAgBpD,GAGwCwD,EAAQxD,GAAjEyH,EAlB8D,EAkB9DA,MAAOE,EAlBuD,EAkBvDA,UAEf,MAAO,CAAEF,QAAOE,YAAWxF,SAAQqB,UA/FVqE,CAAgB7H,EAAOmC,GAG1C8C,EA8MR,SAAwBjF,GAEtB,IAAMiF,EAAoB,GAEpB6C,EAA0B,GAG1BxH,EAAM,SAANA,EAAOC,EAAcwH,EAA0BhG,GACnD,IAAM2D,EAAexF,OAAOC,KAAK4H,GAAKlB,KAAK,OACtCiB,EAASpC,IAASA,IACrBoC,EAASpC,IAAQ,GAGnB,sBAAI1F,EAAMO,GAAMe,SAAhB,YAA4BtB,EAAMO,GAAMG,WAAUN,SAAQ,SAACC,GACzD,IAAK0H,EAAI1H,KAAOL,EAAMK,GAAGW,UAAW,CAClC,IAAM0E,EAAexF,OAAOC,KAAK4H,GAAKlB,KAAK,MACvCiB,EAASpC,WACJoC,EAASpC,GAElBpF,EAAID,EAAD,eAAS0H,EAAT,eAAe1H,GAAI,IAAQ0B,QAM9BiG,EAAM,SAACzH,GAIX,IAHA,IAAMuH,EAA2B,GAC3BG,EAAkB,CAAC1H,GAFgB,aAKvC,IAAMsD,EAAIoE,EAAMC,MAEXJ,EAASjE,KACZiE,EAASjE,GAAK,IAGhB,sBAAI7D,EAAM6D,GAAGnD,UAAb,YAA0BV,EAAM6D,GAAGvC,UAASlB,SAAQ,SAACC,GAC9CyH,EAASzH,IAAOL,EAAMK,GAAGW,WAC5BiH,EAAM3F,KAAKjC,GAERL,EAAMK,GAAGW,WACZ8G,EAASjE,GAAGvB,KAAKjC,OAZhB4H,EAAMhF,QAAS,IAiBtB,IAAMkF,EAAmBjI,OAAOiI,OAAOL,GAAUM,QAAO,SAACL,EAAe5G,GAAhB,4BAAoC4G,GAApC,YAA4C5G,MAAI,IACxG,OAAO,IAAIa,IAAImG,IAIjB,IAAK,IAAM9E,KAAOrD,EACZA,EAAMqD,GAAKrC,WACbV,GAAK+C,EAAK,IAAKA,GAGZrD,EAAMqD,GAAKrC,WAAchB,EAAMqD,GAAKO,OACvCqB,EAAQ,GAAD,OAAI5B,IAAS2E,GAAK3E,IAKNnD,OAAOC,KAAK2H,GAE9B1H,SAAQ,SAACiI,GACZ,IAAM3C,EAAiB2C,EAAOC,MAAM,MAC9BvG,EAAO2D,EAAK,GACZL,EAAKK,EAAKA,EAAKzC,OAAS,GAG1BjD,GAAO+B,GAAM6B,OACfqB,EAAQ,GAAD,OAAIlD,EAAJ,aAAasD,IAAQ,IAAIrD,IAAI0D,EAAKlD,KAAI,SAACnC,GAAD,OAAgBA,UAYjE,IAPA,IAMMQ,EAAmCX,OAAOW,QAAQoE,GAC/CxB,EAAY,EAAGA,EAAI5C,EAAQoC,OAAQQ,IAC1C,IAAK,IAAIE,EAAYF,EAAI,EAAGE,EAAI9C,EAAQoC,OAAQU,IAR7B4E,EASD1H,EAAQ4C,GAAG,GATO+E,EASH3H,EAAQ8C,GAAG,GARxC4E,EAAG1F,OAAS2F,EAAG3F,MACZf,MAAMC,KAAKwG,GAAItH,OAAO4F,KAAK,MAAQ/E,MAAMC,KAAKyG,GAAIvH,OAAO4F,KAAK,YAQ1D5B,EAAQpE,EAAQ4C,GAAG,IAVZ,IAAC8E,EAAiBC,EAetC,OAAOvD,EAzSmBwD,CAAezI,GAGnC0I,EAAoC,GAGpCC,EAAgC,GAGhCC,EAAoC,GAsD1C,OAnD2B,SAArBC,EAAsB7I,EAAemC,EAAiB8C,GAE1D,IAAI6D,EAGElI,EAAsBV,OAAOW,QAAQoE,GAKrC8D,EAA6BnI,EAChC4B,KAAI,SAACwG,EAAevF,GACnB,IAAM8B,EAAgB9D,KAAK2D,IAAI4D,EAAE,GAAGnG,KAAOsE,EAAIM,OACzCwB,EAAsBnH,MAAMC,KAAKiH,EAAE,IAAIlI,QAAO,SAACT,GAAD,OAAgBL,EAAMK,GAAGuD,QAG7E,MAAO,CAAC2B,EAAO9B,EAFWhC,KAAK2D,IAAI6D,EAAUhG,OAASkE,EAAIQ,WACjCiB,GAAeI,EAAE,KAkRlD,SAA2BX,EAAoBrI,EAAe4I,GAC5D,IAAIM,EAAe,EAOnB,OALAb,EAAO,GAAGjI,SAAQ,SAACC,GACjB6I,GAAQlJ,EAAMK,GAAGiD,KAGnBsF,GAAeP,EAAO,IAAM5G,KAAK0H,MAAMD,EAAOb,EAAO,GAAGxF,MACjD+F,GAAeP,EAAO,IA1R0Be,CAAkBJ,EAAGhJ,EAAO4I,OAG9E3H,MAAK,SAACoI,EAAcC,GAAf,OAAgCD,EAAG,GAAKC,EAAG,IAAMD,EAAG,GAAKC,EAAG,IAAMA,EAAG,GAAKD,EAAG,MAErF,GAAIN,EAAe9F,OAAS,EAAG,CAE7B,IAAMoB,EAAgB0E,EAAe,GAAG,GAQlCQ,EAAqBrJ,OAAOC,KAAKuI,GAAgBzF,OAGvD6F,EAAalI,EAAMyD,GAEdqE,EAAeI,EAAW,MAC7B3B,EAiGR,SACEnH,EACA8I,EACA3B,EACAuB,EACAC,EACAa,QAGsCtG,IAAlCwF,EAAeI,EAAW,MAC5BJ,EAAeI,EAAW,IAAMA,EAAW,IAI7C,IAAIW,EAAyB,EAEzBC,EAAyB,EAGzBC,GAAmB,EA+BvB,OA5BAb,EAAW,GAAG1I,SAAQ,SAACG,GAWrB,GAVKoI,EAAepI,KAClBkJ,IAEKzJ,EAAMO,GAAMqD,MACf8F,KAMC1J,EAAMO,GAAMqD,KASf5D,EAAMO,GAAM+C,EAAI6D,EAAI3D,QAAUxD,EAAMO,GAAM+C,EAAI6D,EAAI3D,aARlD,IAAK,IAAIC,EAAY0D,EAAI3D,OAAS,EAAGC,GAAK,EAAGA,IAC3C,QAAqCP,IAAjCiE,EAAIhF,OAAOnC,EAAMO,GAAMiB,GAAGiC,GAAkB,CAC9CzD,EAAMO,GAAM+C,EAAIG,EAChB0D,EAAIhF,OAASiB,EAAgBpD,GAC7B,MAON2J,GAAU,EACVhB,EAAepI,IAAQ,EACvBiJ,OAGK,eACFrC,EADL,CAEEhF,OAAQiB,EAAgBpD,GACxByH,MAAOkC,EAAUxC,EAAIM,MAAQgC,EAAiBtC,EAAIM,MAClDE,UAAWgC,EAAUxC,EAAIQ,UAAY+B,EAAiBvC,EAAIQ,YAvJhDiC,CAAY5J,EAAO8I,EAAY3B,EAAKuB,EAAgBC,GAXzC,kBACV1D,EAAQrE,EAAMyD,GAAO,QAc1B8C,EAAIM,MAAQ,GAAK8B,IAAerJ,OAAOC,KAAKuI,GAAgBzF,QAC9D4F,EAAmB7I,EAAOmH,EAAIhF,OAAQ8C,IAK5C4D,CAAmB7I,EAAOmC,EAAQ8C,GAGlC1B,EAASvD,EAAOmH,EAAI3D,QAEb,CACLA,OAAQ2D,EAAI3D,OACZrB,OAAQiB,EAAgBpD,K,4BC1Ef6J,EAAY,SACvB/E,EACA9E,EACAiF,EACAlF,EACA+J,EACAC,GAGA,IAAMC,EAAgB,GAEtB,GAAIF,EAAO,CAET,IAAMG,EAAaH,EAAMI,cAAc,OACnCD,GACFH,EAAMK,YAAYF,GAIpB,IAAIG,EAAeC,OAAOC,iBAC1BpK,OAAOiI,OAAOnI,GAAOI,SAAQ,SAACmK,GAC5BH,EAAO3I,KAAKwE,IAAImE,EAAMG,EAAEvD,IAAIwD,UAAUlH,MAMxC8G,EAAO3I,KAAKwE,IAAImE,EAFa,GAEQN,EAAMW,aAG3C,IAAMC,EAAMC,IAAUb,GAAOc,OAAO,OAAOC,KAAK,QAAST,GAAMS,KAAK,SAAUf,EAAMgB,cAnB3E,EAuGb,SAAmB9K,EAAeiF,EAAmBH,EAAgBiG,GACnE,IAAIC,EAAmC,GAGjCC,EAA8B,GAGpC,IAAK,IAAM5H,KAAO4B,EAAS,CAAC,IAAD,EACN5B,EAAIiF,MAAM,MADJ,mBAClBvG,EADkB,KACZsD,EADY,KAEzB2F,EAAO3H,GAAO,GACd2H,EAAO3H,GAAKf,KAAK4I,EAAgBlL,GAAO+B,KAMxC,IAJA,IAAMnB,EAAkBkB,MAAMC,KAAKkD,EAAQ5B,IAEvC8H,GAA0B,EAErB1H,EAAY,EAAGA,EAAI7C,EAAMqC,OAAQQ,IACxC,GAAI7C,EAAM6C,MAAQ1B,GAAQnB,EAAM6C,MAAQ4B,EAAxC,CAGA,IAAMxB,EAAsBqH,EAAgBlL,EAAMY,EAAM6C,KACnD0H,IACHF,EAAc3I,KAAK,CAACuB,EAAE,GAAIA,EAAE,IAAK9B,GAAOsD,IACxC8F,GAAiB,GAEnBH,EAAO3H,GAAKf,KAAKuB,GAGnBmH,EAAO3H,GAAKf,KAAK4I,EAAgBlL,GAAOqF,KAiD1C,OA7CAP,EAAM1E,SAAQ,SAACkF,GACb,IAAM8F,EAAU,UAAM9F,EAAKvD,KAAX,aAAoBuD,EAAKD,IAGnCgG,EAAiB,UAAM/F,EAAKD,GAAX,aAAkBC,EAAKvD,MAE9C,QAAmBmB,IAAf8H,EAAOI,KAAsBpL,EAAMsF,EAAKvD,MAAM6B,OAAS5D,EAAMsF,EAAKD,IAAIzB,KAAM,CAE9E,IASI0H,EATEC,EAA0BL,EAAgBlL,EAAMsF,EAAKvD,OAErDyJ,EAAyBN,EAAgBlL,EAAMsF,EAAKD,KAGtDoG,EAAiB,EAEjBC,EAAiB,EAKjBV,EAAOK,KACTI,EAAS,IAIPnG,EAAKvD,OAASuD,EAAKD,KACrBoG,EAAS,GACTC,EAAS,GAETH,EAAM,IAAMR,EAAKY,MAAQ,EACzBJ,EAAM,IAAMR,EAAKa,OAAS,EAE1BJ,EAAK,IAAMT,EAAKY,MAAQ,EAAIF,EAC5BD,EAAK,IAAMT,EAAKa,OAAS,EAGzBH,GAAUA,EAAS,GAGrBH,EAAM,EAAEC,EAAM,GAAKC,EAAK,IAAM,EAAIC,GAASF,EAAM,GAAKC,EAAK,IAAM,EAAIE,GACrET,EAAc3I,KAAK,CAACgJ,EAAI,GAAIA,EAAI,GAAIhG,EAAKvD,KAAMuD,EAAKD,KACpD2F,EAAOI,GAAM,CAACG,EAAOD,EAAKE,OAIvB,CACLK,OAAQb,EACRC,iBAjKiDa,CAAU9L,EAAOiF,EAASH,EAAOiF,EAAOgB,MAAjFc,EArBC,EAqBDA,OAAQZ,EArBP,EAqBOA,cArBP,WAuBEvF,GACT,IAAIsF,EAA6Ba,EAAOnG,GAxBjC,EA2BsBA,EAAK4C,MAAM,MA3BjC,mBA2BAvG,EA3BA,KA2BMsD,EA3BN,KA8BD0G,EAAQhK,IAASsD,EAAKsF,IAAgBA,IAGtCqB,EAAIrB,MAEPrH,GAAE,SAAC2I,GAAD,OAAOA,EAAE,MACXzK,GAAE,SAACyK,GAAD,OAAOA,EAAE,MACXF,MAAMA,GAGH/K,EACJe,IAASsD,GAAMtF,EAAQyC,KAAI,SAACnC,EAAWoD,GAAZ,gBAA6BpD,EAA7B,aAAmCN,EAAQ0D,EAAI,OAAMoC,SAASH,GAGvFwG,GAAoB,EAGlB5G,EAA0BR,EAAMN,MAAK,SAACrD,GAAD,OAAcA,EAAEY,QAAUA,GAAQZ,EAAEkE,MAAQA,KACnFC,GAAQA,EAAK6G,QAA0B,aAAhB7G,EAAK6G,SAC9BD,GAAW,GAIb,IAAME,EAAcC,EAAS3B,EAAKsB,EAAEhB,GAAStF,EAAM1E,EAAWkL,EAAUnC,EAAOuC,QAGzEC,EAwIZ,SAA2BvM,EAAeO,EAAcmK,GACtD,IAAM7G,EAAgB7D,EAAMO,GAGtB0L,EAAS,YAAQpI,EAAEmD,IAAIwD,UAAUlH,EAAI,EAA5B,YAAiCO,EAAEmD,IAAIwD,UAAUhJ,EAAI,EAArD,cAA4DqC,EAAEmD,IAAI2E,MAAQ,GAA1E,kCACM9H,EAAEmD,IAAI4E,OAAS,KADrB,oCAEO/H,EAAEmD,IAAIwD,UAAUlH,EAAI,EAF3B,qCAGQO,EAAEmD,IAAIwD,UAAUhJ,EAAI,EAH5B,4BAiBf,OARakJ,EACVE,OAAO,QACPC,KAAK,IAAKoB,GACVpB,KAAK,KAHK,eAGStK,IACnBiM,MAAM,SAAU,eAChBA,MAAM,OAAQ,eACdA,MAAM,eAAgB,OAEbC,QAAQ,GAAG,GA7JYC,CAAkB1M,GAAQqF,EAAIqF,GAGvDiC,EAAeC,IAEnBR,EAAYS,aAAa,KAEzBN,EAAOM,aAAa,MAGtB,GAAIF,EAAa1J,OAAS,EAAG,CAE3B+H,EAAO9C,MAEP8C,EAAO1I,KAAK,CAACqK,EAAa,GAAGrJ,EAAGqJ,EAAa,GAAGnL,IAEhD4K,EAAYU,SAGZ,IAAMC,EAAOV,EAAS3B,EAAKsB,EAAEhB,GAAStF,EAAM1E,EAAWkL,EAAUnC,EAAOuC,QACxEtC,EAAMtE,GAAQ,CACZqH,OACAb,WACAc,MAAO,CACLC,QAASf,EAAWnC,EAAOuC,OAAOJ,SAAWnC,EAAOuC,OAAOY,QAC3DC,MAAOpD,EAAOuC,OAAOa,OAEvBC,OAAQ,CACNH,QAASf,EAAWnC,EAAOsD,QAAQnB,SAAWnC,EAAOsD,QAAQH,QAC7DC,MAAOpD,EAAOsD,QAAQF,UA9D9B,IAAK,IAAMzH,KAAQmG,EAAS,EAAjBnG,GAqEX4H,EAAa5C,EAAKX,EAAOuC,OAAOY,QAASnD,EAAOsD,QAAQH,SACxDI,EAAa5C,EAAKX,EAAOuC,OAAOJ,SAAUnC,EAAOsD,QAAQnB,UACzDoB,EAAa5C,EAAKX,EAAOuC,OAAOa,MAAOpD,EAAOsD,QAAQF,OA8I1D,SAAuBlC,EAA6BnG,EAAgB4F,GAElE,IAAMlI,EAAoBsC,EAAMsD,QAAO,SAACL,EAAmBzC,EAAa7B,GACtE,IAAM2H,EAAU,UAAM9F,EAAKvD,KAAX,aAAoBuD,EAAKD,IAIzC,YAHgBnC,IAAZ6E,EAAIqD,KACNrD,EAAIqD,GAAM3H,GAELsE,IACN,IAEHkD,EAAc7K,SAAQ,SAACqG,GAErB,IAAMpC,EAAgB7B,EAAI,GAAD,OAAIiE,EAAE,GAAN,aAAaA,EAAE,KAClC8G,EAA4BzI,EAAMT,GAAOmJ,SAAY1I,EAAMT,GAAOmJ,QAAyBD,WAAQrK,EAEzGwH,EACGE,OAAO,QACPC,KACC,QAHJ,oCAKI/F,EAAMT,GAAO8H,QAAkC,aAAxBrH,EAAMT,GAAO8H,OAAwB,8BAAgC,KAE7FtB,KAAK,IAAKpE,EAAE,GAAK,GACjBoE,KAAK,IAAKpE,EAAE,IACZgH,KAAKF,MApKRG,CAAczC,EAAenG,EAAO4F,GAGtC,OAAOV,GAwFT,SAASkB,EAAgB3K,GACvB,MAAO,CAACA,EAAKyG,IAAIwD,UAAUlH,EAAI/C,EAAKyG,IAAI2E,MAAQ,EAAGpL,EAAKyG,IAAIwD,UAAUhJ,EAAIjB,EAAKyG,IAAI4E,OAAS,GA6B9F,SAAS0B,EAAa5C,EAAUsC,EAAe5B,GAC7CV,EACGE,OAAO,QACPA,OAAO,UACPC,KAAK,KAAMO,GACXP,KAAK,UAAW,WAChBA,KAAK,OAAQ,KACbA,KAAK,OAAQ,OACbA,KAAK,cAAe,eACpBA,KAAK,cAAe,KACpBA,KAAK,eAAgB,KACrBA,KAAK,SAAU,QACfA,KAAK,OAAQmC,GACbpC,OAAO,QACPC,KAAK,IAAK,yBACVD,OAAO,QAiCZ,SAASyB,EACP3B,EACAiD,EACAvC,EACApK,EACAkL,EACAI,GAYA,OAVa5B,EACVE,OAAO,QAEPC,KAAK,KAAMO,GACXP,KAAK,IAAK8C,GACVnB,MAAM,OAAQ,QACdA,MAAM,SAAUN,EAAWI,EAAOJ,SAAWI,EAAOY,SACpDV,MAAM,eAAgBxL,EAAY,MAAQ,OAC1C6J,KAAK,aARK,eAQiBqB,EAAW,yBAA2B,eARvD,MAUDO,QAAQ,GAAG,GClTlB,ICkBMmB,EAAb,WAiDE,WAAmBC,GAAmB,yBAAnBA,OAAkB,KA/C9B7N,MAAgB,GA+Cc,KA7C9BmC,OAAkB,GA6CY,KA3C9BqB,OAAiB,EA2Ca,KAzC9BzD,QAAoB,GAyCU,KAvC9B+N,OAAiB,EAuCa,KArC9B9J,KAAe,EAqCe,KAnC9B8F,MAA+B,KAmCD,KAjC9B7E,QAAoB,GAiCU,KA/B9BH,MAAiB,GA+Ba,KA5B9BiG,KAAc,CACnBY,MAAO,IACPC,OAAQ,GACRmC,IAAK,GACLC,UAAW,IAwBwB,KApB9B1B,OAAkB,CACvBY,QAAS,UACTC,MAAO,UACPjB,SAAU,WAiByB,KAb9BmB,QAAoB,CACzBH,QAAS,eACTC,MAAO,sBACPjB,SAAU,0BAUyB,KAN9BnC,OAAkB,CACvBgB,KAAMkD,KAAKlD,KACXuB,OAAQ2B,KAAK3B,OACbe,QAASY,KAAKZ,SA9ClB,mDAqDI,GAA+B,IAA3BY,KAAKJ,KAAKjN,MAAMqC,OAClB,MAAO,CACLiL,MAAO,GACPlO,MAAO,IAKXiO,KAAKjO,MCtFkB,SAAC6N,GAE1B,IAAM7N,EAAgB,GAsBtB,OATA6N,EAAK/I,MAAM1E,SAAQ,SAACkF,GAClB,CAACA,EAAKvD,KAAMuD,EAAKD,IAAIjF,SAAQ,SAACkF,QACZpC,IAAhBlD,EAAMsF,KAAwBtF,EAAMsF,GAAQ6I,KAAKC,MAb/B,+JAgBpBpO,EAAMsF,EAAKD,IAAI/D,QAAQgB,KAAKgD,EAAKvD,MAEjC/B,EAAMsF,EAAKvD,MAAMrB,SAAS4B,KAAKgD,EAAKD,OAE/BrF,ED8DQqO,CAAYJ,KAAKJ,MAG9B,IAAMS,EEzFoB,SAACJ,EAAgBlO,GAG7C,IAFA,IAAMyF,EAAmB,GAEhBhC,EAAY,EAAGA,EAAIyK,EAAMjL,OAAQQ,IAAK,CAAC,IAAD,IAW7C,GAVqC,WAAjC,UAAAyK,EAAMzK,GAAGlC,YAAT,eAAegN,iBACjB9I,EAAO,GAAKhC,EACZzD,EAAMyD,GAAGlC,KAAO,SAGmB,SAAjC,UAAA2M,EAAMzK,GAAGlC,YAAT,eAAegN,iBACjB9I,EAAO,GAAKhC,EACZzD,EAAMyD,GAAGlC,KAAO,OAGI,IAAlBkE,EAAOxC,OACT,MAIJ,OAAOwC,EFsEsB+I,CAAeP,KAAKJ,KAAKK,MAAOD,KAAKjO,OAChEiO,KAAKH,MAAQQ,EAAS,GACtBL,KAAKjK,IAAMsK,EAAS,GAEpBL,KAAKlO,QAAL,CAAgBkO,KAAKH,OAArB,mBAA+BG,KAAKJ,KAAKjN,MAAM,GAAG8E,MAAlD,CAAwDuI,KAAKjK,MAC7DiK,KAAKnJ,MAAL,YAAiBmJ,KAAKJ,KAAK/I,OAG3BmJ,KAAK9L,OAASxB,EAAQsN,KAAKJ,KAAMI,KAAKjO,MAAOiO,KAAKlO,SAGlDkO,KAAK9L,OAAS4B,EAASkK,KAAKjO,MAAOiO,KAAK9L,OAAQ8L,KAAKjK,KAGrD,IAAMyK,EAAqB5J,EAAgBoJ,KAAKnJ,MAAOmJ,KAAKjO,MAAOiO,KAAK9L,OAAQ8L,KAAKlO,SACrFkO,KAAKhJ,QAAUwJ,EAAMxJ,QACrBgJ,KAAK9L,OAASiB,EAAgB6K,KAAKjO,OAGnC,IAAM0O,EAA0BxH,EAAU+G,KAAKlO,QAASkO,KAAKjO,MAAOiO,KAAK9L,QACzE8L,KAAKzK,OAASkL,EAAQlL,OACtByK,KAAK9L,OAASuM,EAAQvM,OAMtB,IAAMwM,ED7GwB,SAChC3O,EACAwD,EACAuH,EACA9F,GAKA,IAAI9C,EAAkBiB,EAAgBpD,GAGhC4O,EAAsB,GACtBC,EAAuB,GAE7B3O,OAAOC,KAAK8E,GAAS7E,SAAQ,SAACiD,GAC5B,IAAMyL,EAAkBhN,MAAMC,KAAKkD,EAAQ5B,IAGrCiE,EAAiBwH,EAAMC,OAAM,SAAC1O,GAAD,OAAeL,EAAMK,GAAGiD,EAAIE,KACzD6D,EAAgByH,EAAMC,OAAM,SAAC1O,GAAD,OAAeL,EAAMK,GAAGiD,EAAIE,KAE1D8D,IAAOuH,EAAWxL,GAAO4B,EAAQ5B,IACjCgE,IAAMuH,EAAUvL,GAAO4B,EAAQ5B,OAIrC,IAAM2L,EAA4B9O,OAAOW,QAAQ+N,GAC3CK,EAA6B/O,OAAOW,QAAQgO,GAG5C/K,EAAQ,SAACR,EAAWoC,GAExB,IADA,IAAIwJ,GAAiB,EACZzL,EAAY,EAAGA,EAAIiC,EAAKzC,OAAQQ,IACvC,GAAKzD,EAAM0F,EAAKjC,IAAIG,KAApB,CAIA,IAAMpC,EAAYxB,EAAM0F,EAAKjC,IAAIjC,EAGjC,KAFA0N,OAAyBhM,IAAjBf,EAAOX,GAAG8B,SAAsCJ,IAAjBf,EAAOX,GAAG8B,IAAoBoC,EAAKxB,QAAQ/B,EAAOX,GAAG8B,KAAiB,GAG3G,MAIJ,GAAI4L,EAAO,CACT,IAAK,IAAIzL,EAAY,EAAGA,EAAIiC,EAAKzC,OAAQQ,IACnCzD,EAAM0F,EAAKjC,IAAIG,OACjB5D,EAAM0F,EAAKjC,IAAIH,EAAIA,GAIvBnB,EAASiB,EAAgBpD,KAK7BgP,EAAY5O,SAAQ,SAACe,GACnB,IAAMuE,EAAiB5D,MAAMC,KAAKZ,EAAE,IAChCmC,EAAY+G,OAAO8E,iBAMvB,IAJAzJ,EAAKtF,SAAQ,SAACC,GACZiD,EAAI7B,KAAK2N,IAAIpP,EAAMK,GAAGiD,EAAGA,MAGnBA,EAAIE,EAAQF,IAClBQ,EAAMR,EAAGoC,MAKbuJ,EAAa7O,SAAQ,SAACe,GACpB,IAAMuE,EAAiB5D,MAAMC,KAAKZ,EAAE,IAChCmC,EAAY+G,OAAOC,iBAMvB,IAJA5E,EAAKtF,SAAQ,SAACC,GACZiD,EAAI7B,KAAKwE,IAAIjG,EAAMK,GAAGiD,EAAGA,MAGnBA,EAAIE,EAAQF,IAClBQ,EAAMR,EAAGoC,MAKb,IAAMvF,EAAiBD,OAAOC,KAAKH,GAE/BoP,EAAc/E,OAAO8E,iBAWzB,OAVAhP,EAAKC,SAAQ,SAACC,GACZ+O,EAAM3N,KAAK2N,IAAIA,EAAKpP,GAAOK,GAAGiD,MAGhCnD,EAAKC,SAAQ,SAACC,GACZL,GAAOK,GAAGiD,GAAK8L,KAKV,CACL5L,OAHwBA,EAAS4L,EAIjCxO,MAAO,CAACoO,EAAaC,ICQTI,CAAmBpB,KAAKjO,MAAOiO,KAAKzK,OAAQyK,KAAKlD,KAAMkD,KAAKhJ,SACxEgJ,KAAKzK,OAASmL,EAAInL,OAGlB,IAAM0K,EGnHiB,SAAClO,EAAe6N,EAAkB9C,GAE3D,IAAMlH,EAAcgK,EAAKK,MAAM9F,QAAO,SAACL,EAAe1H,GAIpD,OAHIA,EAAEmN,SACJzF,EAAIzF,MAAMjC,EAAEmN,QAAQ8B,SAEfvH,IACN,IACHlE,EAAE5C,OACF,IAAMsO,EAAmB1L,EAAEpC,KAAKiG,MAAM7D,EAAEZ,OAAS,IAEjD,OAAO/C,OAAOC,KAAKH,GAAOwC,KAAI,SAACnC,GAAe,IAAD,IAC3CL,GAAOK,GAAG2G,IAAM,CACd2E,MAAO3L,GAAOK,GAAG2G,IAAI2E,OAASZ,EAAKY,MACnCC,OAAQ5L,GAAOK,GAAG2G,IAAI4E,QAAUb,EAAKa,OACrCpB,UAAW,CACTlH,GAAG,UAAAtD,GAAOK,GAAG2G,IAAIwD,iBAAd,eAAyBlH,IAAKtD,GAAOK,GAAGiD,GAAKyH,EAAKY,MAAQZ,EAAKgD,KAClEvM,GAAG,UAAAxB,GAAOK,GAAG2G,IAAIwD,iBAAd,eAAyBhJ,IAAKxB,GAAOK,GAAGmB,GAAKuJ,EAAKa,OAASb,EAAKgD,OAIvE,IAAIyB,GAAuB,EAK3B,OAJI3B,EAAKK,OAAO7N,IAAMwN,EAAKK,OAAO7N,GAAGmN,UACnCgC,EAAe3B,EAAKK,OAAO7N,GAAGmN,QAAyB8B,QAAUC,EAAW,GAAMA,GAG7E,CACL7K,KAAMrE,EACNE,KAAMsN,EAAKK,OAAO7N,GAClBiD,EAAGtD,GAAOK,GAAGiD,EACb9B,EAAGxB,GAAOK,GAAGmB,EACbzB,QAASC,GAAOK,GAAGW,UACnB4C,KAAM5D,GAAOK,GAAGuD,KAChBoD,IAAKhH,GAAOK,GAAG2G,IACfwI,kBHiFiBC,CAAYxB,KAAKjO,MAAOiO,KAAKJ,KAAMI,KAAKlD,MAsB3D,OI7I2B,SAACnK,EAAuBmK,EAAa/K,EAAewD,GACjF,IAAIrB,EAAkBiB,EAAgBpD,GAGlCoP,EAAc/E,OAAO8E,iBACrBlJ,EAAcoE,OAAOC,iBAEzBnI,EAAO/B,SAAQ,SAAC0G,GACdA,EAAI1G,SAAQ,SAACC,QACD6C,IAAN7C,GAAoBL,EAAMK,GAAGuD,OAC/BwL,EAAM3N,KAAK2N,IAAIA,EAAKpP,EAAMK,GAAGiD,GAC7B2C,EAAMxE,KAAKwE,IAAIA,EAAKjG,EAAMK,GAAGiD,UAMnC,IAAM+D,EAAmBzG,EAAM,GAC5B4B,KAAI,SAACrB,GAAD,OAAmBW,MAAMC,KAAKZ,EAAE,IAAIL,QAAO,SAACT,GAAD,OAAeL,EAAMK,GAAGuD,MAAQ5D,EAAMK,GAAGiD,EAAI8L,QAC5FtO,QAAO,SAACK,GAAD,OAAiBA,EAAE8B,UAC1BhC,MAAK,SAACF,EAAaG,GAAd,OAA8BlB,EAAMkB,EAAE,IAAIoC,EAAItD,EAAMe,EAAE,IAAIuC,KAE9DA,EAAY8L,EAEhB/H,EAAKjH,SAAQ,SAAC8N,GACZA,EAAM9N,SAAQ,SAACC,GACTL,EAAMK,GAAGiD,IAAMA,IACjBA,EAAItD,EAAMK,GAAGiD,GAGftD,EAAMK,GAAG2G,IAAI2E,MAAQZ,EAAKiD,UAC1BhO,EAAMK,GAAG2G,IAAIwD,UAAUlH,IAAMyH,EAAKY,MAAQZ,EAAKiD,YAAcoB,EAAM9L,SAKvE,IAAMgE,EAAoB1G,EAAM,GAC7B4B,KAAI,SAACrB,GAAD,OAAmBW,MAAMC,KAAKZ,EAAE,IAAIL,QAAO,SAACT,GAAD,OAAeL,EAAMK,GAAGuD,MAAQ5D,EAAMK,GAAGiD,EAAI2C,QAC5FnF,QAAO,SAACK,GAAD,OAAiBA,EAAE8B,UAC1BhC,MAAK,SAACF,EAAaG,GAAd,OAA8BlB,EAAMe,EAAE,IAAIuC,EAAItD,EAAMkB,EAAE,IAAIoC,KAElEA,EAAI2C,EAEJqB,EAAMlH,SAAQ,SAAC8N,GACbA,EAAM9N,SAAQ,SAACC,GACTL,EAAMK,GAAGiD,IAAMA,IACjBA,EAAItD,EAAMK,GAAGiD,GAGftD,EAAMK,GAAG2G,IAAI2E,MAAQZ,EAAKiD,UAEtB1K,EAAI2C,IACNjG,EAAMK,GAAG2G,IAAIwD,UAAUlH,IAAMyH,EAAKY,MAAQZ,EAAKiD,YAAc1K,EAAI2C,EAAM,UJsE3EyJ,CAAgBf,EAAI/N,MAAOqN,KAAKlD,KAAMkD,KAAKjO,MAAOiO,KAAKzK,QK1HhC,SAACxD,GAE1B,IAAI2P,EAAetF,OAAO8E,iBAEpBhP,EAAiBD,OAAOC,KAAKH,GAEnCG,EAAKC,SAAQ,SAACiD,GACZsM,EAAOlO,KAAK2N,IAAIO,EAAM3P,GAAOqD,GAAK2D,IAAIwD,UAAUlH,MAIlDnD,EAAKC,SAAQ,SAACiD,GACZrD,GAAOqD,GAAK2D,IAAIwD,UAAUlH,GAAKqM,KLiH/BC,CAAY3B,KAAKjO,OAEjBiO,KAAK9L,OAASiB,EAAgB6K,KAAKjO,OAEnC6P,QAAQC,IAAI,0CAAa,kBACzBD,QAAQC,IAAI7B,KAAKJ,MACjBgC,QAAQC,IAAI,yBAA0B,kBAEtCD,QAAQC,IAAI,8BAAW,kBACvBD,QAAQC,IAAI7B,KAAKjO,OACjB6P,QAAQC,IAAI,yBAA0B,kBAEtCD,QAAQC,IAAI,gDAAc,kBAC1BD,QAAQC,IAAI7B,KAAK9L,QACjB0N,QAAQC,IAAI,yBAA0B,kBAE/B,CACL5B,QACAlO,MAAOiO,KAAKjO,SAvHlB,gCA4HmB8J,GAEf,OADAmE,KAAKnE,MAAQA,EACND,EAAUoE,KAAKJ,KAAK/I,MAAOmJ,KAAKjO,MAAOiO,KAAKhJ,QAASgJ,KAAKlO,QAASkO,KAAKnE,MAAOmE,KAAKlE,UA9H/F,+BAkIkBqB,EAAY9H,EAAW9B,GACrCqO,QAAQC,IAAI1E,EAAI9H,EAAG9B,GACnByM,KAAKjO,MAAMoL,GAAIpE,IAAIwD,UAAUlH,EAAIA,EACjC2K,KAAKjO,MAAMoL,GAAIpE,IAAIwD,UAAUhJ,EAAIA,EAC7ByM,KAAKnE,OACPD,EAAUoE,KAAKJ,KAAK/I,MAAOmJ,KAAKjO,MAAOiO,KAAKhJ,QAASgJ,KAAKlO,QAASkO,KAAKnE,MAAOmE,KAAKlE,YAvI1F,KMMegG,G,MA5BqB,SAAC,GAAc,IAAZrN,EAAW,EAAXA,KAE/BsN,EAAuBtN,EAAK8M,YAAc,iCAAmC,gCAEnF,OACE,yBAAKS,UAAS,wBAAmBvN,EAAKnC,KAAKgB,KAAO,wBAA0B,KACzEmB,EAAKnC,KAAKgB,KACT,oCAAoC,UAAjCmB,EAAKnC,KAAKgB,KAAKgN,cAA4B,wFAAoB,mFAElE,oCACG7L,EAAKnC,KAAKiN,SACT,yBAAKyC,UAAU,yBACb,yBAAKA,UAAU,0BAA0BvN,EAAKnC,KAAKiN,QAAQD,SACxD7K,EAAKnC,KAAKiN,QAAQ8B,SACnB,yBAAKW,UAAS,mCAA8BD,IAAiBtN,EAAKnC,KAAKiN,QAAQ8B,QAA/E,MAIN,yBAAKW,UAAU,6BACb,uBAAGA,UAAU,sBAAsBvN,EAAKnC,KAAKmE,KAAK6J,oBCxB/C2B,ECQiB,SAAC,GAAc,IAAZrC,EAAW,EAAXA,KAE3B/D,EAAQqG,iBAAuB,MAFO,EAIlBC,qBAJkB,mBAIrCpQ,EAJqC,KAI9BqQ,EAJ8B,OAMlBD,mBAAyB,IANP,mBAMrClC,EANqC,KAM9BoC,EAN8B,KAQtCtG,EAAQmG,iBAAe,IAGvBI,EAAgBJ,iBAAsC,CAAE9I,KAAM,EAAGmJ,IAAK,IAK5EC,qBAAU,WACJ3G,EAAM4G,SAAWxC,EAAMjL,OAAS,GAAKjD,IACvCgK,EAAM0G,QAAU1Q,EAAM6J,UAAUC,EAAM4G,YAEvC,CAAC5G,EAAOoE,EAAOlO,IAKlByQ,qBAAU,WACR,IAAMzQ,EAAQ,IAAI4N,EAAaC,GACvBK,EAAwBlO,EAAM2Q,OAA9BzC,MACRmC,EAASrQ,GACTsQ,EAASpC,KACR,CAACL,IAKJ,IAAM+C,EAAWT,kBAAgB,GAE3BU,EAAeV,iBAAY,MAG3BW,EAAc,SAAC3P,GAEnB0P,EAAaH,QAAUvP,EAAE4P,eAIrBC,EAAY,WAChBJ,EAASF,SAAU,EACnBG,EAAaH,QAAU,MAGnBO,EAAc,SAAC9P,GACnB,GAAI0P,EAAaH,SAAWE,EAASF,QAAS,CAC5CvP,EAAE+P,kBACF,IAAM5N,EAAInC,EAAEgQ,QAAUN,EAAaH,QAAQU,YAAc,EAAIb,EAAcG,QAAQrJ,KAC7E7F,EAAIL,EAAEkQ,QAAUR,EAAaH,QAAQY,aAAe,EAAIf,EAAcG,QAAQF,IACpFK,EAAaH,QAAQlE,MAAM+E,UAA3B,oBAAoDjO,EAApD,eAA4D9B,EAA5D,SAKJiP,qBAAU,WAIR,OAHAe,OAAOC,iBAAiB,UAAWT,GACnCQ,OAAOC,iBAAiB,YAAaR,GAE9B,WACLO,OAAOE,oBAAoB,UAAWV,GACtCQ,OAAOE,oBAAoB,YAAaT,MAEzC,IAKH,IAAMU,EAAe,SAACxQ,GACpB,IAAMyQ,EAAKzQ,EAAE4P,cACb7Q,OAAOC,KAAK6J,EAAM0G,SAAStQ,SAAQ,SAACiD,GACZA,EAAIiF,MAAM,MACxBzC,SAAS+L,EAAGxG,MAAQpB,EAAM0G,QAAQrN,GAAK6I,WAC7ClC,EAAM0G,QAAQrN,GAAK0J,KAAKP,MAAMqF,OAAS7H,EAAM0G,QAAQrN,GAAK2J,MAAMG,MAChEnD,EAAM0G,QAAQrN,GAAK0J,KAAK+E,aAAa,aAArC,eAA2D9H,EAAM0G,QAAQrN,GAAK+J,OAAOD,MAArF,WAMA4E,EAAe,SAAC5Q,GACpB,IAAMyQ,EAAKzQ,EAAE4P,cACb7Q,OAAOC,KAAK6J,EAAM0G,SAAStQ,SAAQ,SAACiD,GACZA,EAAIiF,MAAM,MACxBzC,SAAS+L,EAAGxG,MAClBpB,EAAM0G,QAAQrN,GAAK0J,KAAKP,MAAMqF,OAAS7H,EAAM0G,QAAQrN,GAAK2J,MAAMC,QAChEjD,EAAM0G,QAAQrN,GAAK0J,KAAK+E,aAAa,aAArC,eAA2D9H,EAAM0G,QAAQrN,GAAK+J,OAAOH,QAArF,WAQA+E,EAAW9D,EAAM1L,KAAI,SAACnC,GAC1B,OACE,yBACEgD,IAAKhD,EAAEqE,KACP0G,GAAI/K,EAAEqE,KACNuL,UAAS,sBAAiB5P,EAAEuD,KAAO,oBAAsB,IACzD4I,MAAO,CACLb,MAAOtL,EAAE2G,IAAI2E,MACbC,OAAQvL,EAAE2G,IAAI4E,OACd2F,UAAU,aAAD,OAAelR,EAAE2G,IAAIwD,UAAUlH,EAA/B,eAAuCjD,EAAE2G,IAAIwD,UAAUhJ,EAAvD,QAEXmQ,aAAcA,EACdI,aAAcA,EACdjB,YAAaA,EACbG,YAAaA,EACbD,UAAWA,GACV3Q,EAAEE,MAAQ,kBAAC,EAAD,CAAWmC,KAAMrC,IAEhB,IAAXA,EAAEuD,MAAcvD,EAAEqE,SAOzB,OACE,yBAAKuL,UAAU,QAAQ7E,GAAG,QAAQ6G,IAAKnI,GAEpCkI,IC1HQE,MAZf,WAGE,IAAMrE,EAAO2D,OAAOW,WAEpB,OACE,yBAAKlC,UAAU,OACb,kBAAC,EAAD,CAAOpC,KAAMA,MCCCuE,QACW,cAA7BZ,OAAOa,SAASC,UAEe,UAA7Bd,OAAOa,SAASC,UAEhBd,OAAOa,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLvD,QAAQuD,MAAMA,EAAMC,c","file":"static/js/main.28f639e2.chunk.js","sourcesContent":["import { IGraph, INumberMap } from './interfaces/interfaces';\n\n/** Расставляем processSibling у узлов. 0 - процесс. Чем больше значение, тем дальше от процесса находится узел\n * @param process - последовательность узлов\n * @param graph - граф\n * */\nexport const connectedness = (process: IGraph, graph: IGraph) => {\n  const visited: INumberMap<INumberMap<boolean>> = {};\n\n  const dfs = (node: number, parent: number | null) => {\n    if (!visited[node]) {\n      visited[node] = {};\n    }\n\n    if (parent !== null) {\n      visited[node][parent] = true;\n\n      if (process[node] && !process[parent]) {\n        graph[parent].processSibling = 1;\n      }\n\n      if (!process[node] && process[parent]) {\n        graph[node].processSibling = 1;\n      }\n\n      if (!process[node] && !process[parent]) {\n        graph[node].processSibling = graph[parent].processSibling + 1;\n      }\n    }\n\n    graph[node].children.forEach((n: number) => {\n      if (!visited[n]) {\n        visited[n] = {};\n      }\n\n      if (!graph[n].processSibling && !visited[n][node]) {\n        dfs(n, node);\n      }\n    });\n  };\n\n  Object.keys(graph).forEach((n: string) => {\n    dfs(+n, null);\n  });\n};\n","import { IEntry, IGraph, IGraphData, IMatrix } from './interfaces/interfaces';\nimport { connectedness } from './connectedness';\n\n/** [Описание]\n * [1] Выбираем среди путей путь с наибольшей частотой (весом). Этот путь называется Процесс.\n * Так как массив с бекенда приходит отсортированный, то за процесс берем первый путь paths[0].path.\n * [2] Узлам процесса устанавливается флаг process = 1 и уровень y в том порядке, в котором они находятся.\n * [3] Определяются узлы, связанные с узлами процесса. Для этих узлов устанавливается флаг processSibling = 1.\n * [4] Для всех узлов, не являющихся частью процесса, считается степень приближенности к узлам процесса, а так же узлам\n * для которых уже был определен уровень.\n * [5] Уровень нормализуется, т.е. приводится к последовательности 0, 1, 2..., n.\n * [6] Для следующего шага 'ordering' возвращаются элементы, распределенные по уровням matrix.\n * */\n\n/** Распределение узлов по уровням\n * @param data - данные графа\n * @param graph - граф\n * @param process - процесс */\nexport const ranking = ({ paths }: IGraphData, graph: IGraph, process: number[]): IMatrix => {\n  let matrix: IMatrix = [];\n  const processGraph: IGraph = setProcessRank(process, graph);\n  arrangeRanks(processGraph, graph);\n  matrix = normalize(graph);\n  return matrix;\n};\n\n/** Устанавливаем уровень узлам процесса\n * добавляются флаги в структуру графа только\n * process - узел является узлом основного процесса если 1\n * y - номер уровня в графе\n * @param process - последовательность узлов\n * @param graph - граф */\nfunction setProcessRank(process: number[], graph: IGraph): IGraph {\n  const processGraph: IGraph = {};\n\n  /** Убираем дублирующиеся узлы из процесса с помощью Set */\n  Array.from(new Set(process)).forEach((node: number, rankY: number) => {\n    graph[node].y = rankY + 1;\n    graph[node].isProcess = 1;\n    processGraph[node] = graph[node];\n  });\n  return processGraph;\n}\n\n// /** Определяем узлы, связанные с процессом\n//  * @param process - последовательность узлов\n//  * @param graph - граф */\n// function connectedWithProcess(process: IGraph, graph: IGraph) {\n// for (const node in graph) {\n//   /** Если узел не является узлом процесса и у него еще не определили приближенность к процессу */\n//   if (graph.hasOwnProperty(node) && !graph[node].processSibling && !graph[node].isProcess) {\n//     /** Проверяем, если среди дочерних или родителських узлов есть узел процесса */\n//     const relatives: number[] = [...graph[node].children, ...graph[node].parents];\n//     graph[node].processSibling = +relatives.some((n: number) => process[n] && process[n].isProcess);\n//   }\n// }\n// }\n\n/** Приближаем остальные узлы к уровням узлов процесса по среднему значению уровня\n * @param process - последовательность узлов\n * @param graph - граф */\nfunction arrangeRanks(process: IGraph, graph: IGraph) {\n  /** [1] Определяем узлы, связанные с процессом */\n  connectedness(process, graph);\n\n  /** [2] Сортируем по приближенности к процессу */\n  const entries: IEntry[] = Object.entries(graph)\n    .filter((a: IEntry) => !graph[+a[0]].isProcess)\n    .sort((a: IEntry, b: IEntry) => a[1].processSibling - b[1].processSibling);\n\n  entries.forEach((e: IEntry) => {\n    /** Накопленный уровень всех родственников */\n    let mRank = 0;\n    /** Число учитываемых родственников */\n    let relativesCount: number = 0;\n    /** Узлы, связанные с текущим узлов */\n\n    /** Суммируем уровни всех родственников, кроме конца процесса */\n    [...e[1].children, ...e[1].parents].forEach((n: number) => {\n      if (graph[n].type !== 'end') {\n        mRank += graph[n].y;\n        /** Если узел, не являющийся частью процесса, еще не был переставлен на уровень, то его не учитываем */\n        (graph[n].isProcess || graph[n].y) && relativesCount++;\n      }\n    });\n\n    /** Усредненный уровень. Приведим все к 0.5, чтобы узлы были на одном уровне и граф не расползался в высоту */\n    const y: number = Math.ceil(mRank / relativesCount) + 1;\n    e[1].y = isNaN(y) ? 0 : y;\n  });\n}\n\n/** Нормализация уровней\n * @param graph - граф */\nfunction normalize(graph: IGraph): IMatrix {\n  /** Количество элементов на уровне */\n  const matrix: IMatrix = [];\n\n  /** Собираем массив entries графа, отсортированный по уровню и принадлежности процессу */\n  const entries: IEntry[] = Object.entries(graph).sort(\n    (a: IEntry, b: IEntry) => b[1].isProcess - a[1].isProcess || a[1].y - b[1].y\n  );\n\n  /** Находи конец и ставим его в конец списка */\n  const endIndex: number = entries.findIndex((e: IEntry) => e[1].type === 'end');\n  entries.push(entries[endIndex]);\n  entries.splice(endIndex, 1);\n\n  /** Таблица мэппинга уровня и индекса для нормализации */\n  // const map: INumberMap<number> = {};\n  const map = new Map();\n\n  /** Если в таблице map нет ключа Y, то создаем его и присваиваем ему index. Index увеличиваем на 1.\n   * Если встречаем узел с таким уже записанным в map уровнем, берем нормализованный уровень из map */\n  entries.forEach((item: IEntry) => {\n    // текущий уровень элемента\n    const currentY: number = item[1].y;\n    //текущяя длина массива с уровнями\n    let idx: number = map.size;\n\n    !map.has(currentY) ? map.set(currentY, idx) : (idx = map.get(currentY));\n    /** Если в ряду нет массива, то создаем его */\n    !matrix[idx] && (matrix[idx] = []);\n    /**  если не узел процесса и первый в массиве пропускаем первый элемент*/\n    !item[1].isProcess && !matrix[idx].length && matrix[idx].push(undefined);\n    //Добавляем узел в ряд.\n    matrix[idx].push(+item[0]);\n    graph[+item[0]].y = map.get(currentY);\n  });\n\n  return matrix;\n}\n","/** Перерисовываем матрицу. Это быстрее и проще, чем пересчитывать индексы */\nimport { IGraph, IMatrix } from './interfaces/interfaces';\n\n/** Перераспределение узлов в матрице\n * @param graph - граф */\nexport const rearrangeMatrix = (graph: IGraph): IMatrix => {\n  const matrix: IMatrix = [];\n\n  for (const key in graph) {\n    if (matrix[graph[key].y] === undefined) {\n      matrix[graph[key].y] = [];\n    }\n\n    matrix[graph[key].y][graph[key].x] = +key;\n  }\n\n  return matrix;\n};\n","import { IGraph, IMatrix } from './interfaces/interfaces';\nimport { rearrangeMatrix } from './rearrangeMatrix';\n\n/** Сдвигаем узлы справа от процесса левее, заполняя образовавшиеся пустоты  */\nexport const fillGaps = (graph: IGraph, median: number = 0): IMatrix => {\n  let matrix: IMatrix = rearrangeMatrix(graph);\n\n  /** Идем от медины к концу каждого ряда и переставляем узлы влево на свободную позицию  */\n  for (let i: number = 0; i < matrix.length; i++) {\n    /** Очередь */\n    let undefinedQueue: number[] = [];\n\n    for (let j: number = median; j < matrix[i].length; j++) {\n      if (matrix[i][j] === undefined) {\n        /** Запоминаем пустую ячейку */\n        undefinedQueue.push(j);\n      } else {\n        if (graph[matrix[i][j] as number].fake) {\n          continue;\n        }\n\n        const c: number | undefined = undefinedQueue.shift();\n        if (c) {\n          /** Вставляем узел в первую доступную пустую ячейку */\n          graph[matrix[i][j] as number].x = c;\n          matrix[i][c] = matrix[1][j];\n          matrix[i][j] = undefined;\n          undefinedQueue.push(j);\n        }\n      }\n    }\n  }\n\n  return matrix;\n};\n","import { IEntry, IGraph, IMatrix } from './interfaces/interfaces';\nimport { rearrangeMatrix } from './rearrangeMatrix';\nimport { fillGaps } from './fillGaps';\n\n/** [Описание]\n * [1] В порядке добавления на уровень выводим узлы в ряд\n * [2] В каждом ряду ищем (parent)-->(child) структуру\n * [3] Если находим, сдвигаем (child) на уровень вниз\n * [4] Перераспределяем узлы в матрице */\n\n/** Функция распределения узлов по горизонтали\n * @param graph - граф\n * @param matrix - матрица элементов\n * @param end - индекс последнего узла */\nexport const ordering = (graph: IGraph, matrix: IMatrix, end: number): IMatrix => {\n  /** Выводим все узлы уровня в один ряд */\n  for (const key in graph) {\n    if (!graph[key].isProcess) {\n      const rank: number = graph[key].y;\n      graph[key].x = matrix[rank].indexOf(+key);\n    }\n  }\n\n  /** Передвигаем последний узел на последний ряд, если уже не там и он один на этом ряду */\n  if (matrix[matrix.length - 1].length > 1) {\n    graph[end].y = matrix.length;\n  }\n\n  /** Ищем parent-child структуры и сдвигаем граф */\n  matrix = findParentChild(graph, rearrangeMatrix(graph));\n\n  return fillGaps(graph);\n};\n\n/** Находим узлы на одном уровне и если они являются parent->child структурой, растаскиваем их на разные уровни\n * @param graph - граф\n * @param matrix - массив количества узлов на уровне */\nfunction findParentChild(graph: IGraph, matrix: IMatrix): IMatrix {\n  /** Не эффективно */\n  for (let rank: number = 0; rank < matrix.length; rank++) {\n    const rankNodes: number[] = matrix[rank] as number[];\n\n    /** При динамическом добавлении могут возникнуть пустые ряды, поэтому нужна проверка */\n    if (rankNodes) {\n      rankNodes.forEach((node: number | undefined) => {\n        graph[node as number].children.forEach((child: number) => {\n          const index: number = rankNodes.indexOf(child);\n          /** Если находим... */\n          if (index >= 0 && node !== rankNodes[index]) {\n            /** Меняем child координаты и родительне является ущлов процесса */\n            shiftRanks(rank, node as number, rankNodes[index] as number, graph, matrix);\n            /** И перераспределяем узлы в матрице */\n            matrix = rearrangeMatrix(graph);\n          }\n        });\n      });\n    }\n  }\n\n  return matrix;\n}\n\n/** Сдвигаем уровни\n * @param rank - уровень, на котором происходит сдвиг\n * @param parent - родительский узел\n * @param child - дочерний узел\n * @param graph - граф\n * @param matrix - матрица\n * */\nfunction shiftRanks(rank: number, parent: number, child: number, graph: IGraph, matrix: IMatrix) {\n  /** Сортируем граф по уровням */\n  const entries: IEntry[] = Object.entries(graph).sort((a: IEntry, b: IEntry) => a[1].y - b[1].y);\n\n  /** Родственные элементы дочернего узла */\n  const relatives: number[] = [...graph[child].children, ...graph[child].parents];\n  /** Узел процессса на уровне rank */\n  const processNode: IEntry = entries.find(\n    ([e]: IEntry) => graph[+e[0]].y === rank + 1 && graph[+e[0]].isProcess\n  ) as IEntry;\n\n  /** Новый уровень */\n  let startShiftingRank: number = rank;\n\n  /** Задаем сдвиг на 1 уровень вниз */\n  const condition: boolean =\n    (processNode && relatives.indexOf(+processNode[0]) >= 0) || matrix[rank + 1][graph[parent].x] !== undefined;\n  if (condition) {\n    startShiftingRank = rank + 1;\n  }\n\n  /** Если сдвиг произошел, то сдвигаем все узлы снизу */\n  if (startShiftingRank > rank) {\n    entries.forEach((e: IEntry) => {\n      const name: number = +e[0];\n      /** Когда доходим до уровня, где происходит перемещение узла,\n       * все последующие узлы сдвигаем на один */\n      if (e[1].y >= startShiftingRank) {\n        graph[name].y += 1;\n      }\n    });\n  }\n\n  /** Ставим дочерний узел под родительский. Если он является частью процесса, то меняем только Y */\n  if (!graph[child].isProcess && !graph[parent].isProcess) {\n    graph[child].x = graph[parent].x;\n  }\n  graph[child].y = graph[parent].y + 1;\n}\n","import {\n  IEdge, IFakeResult, IGraph, IGraphNode, IMatrix, IPathMap \n} from './interfaces/interfaces';\nimport { rearrangeMatrix } from './rearrangeMatrix';\n\n/** [Описание]\n * [1] Определяем, если между узлами ребро тянется через >1 уровней\n * [2] Если да, то спускаемся на уровень вниз/поднимаемся вверх и обходим пока что от 0 до бесконечности,\n * пока не найдем свободную ячейку\n * [3] Когда находим свободную ячейку, вставляем в нее новый узел. Повторяем [1].\n * [4] Удаляем ребро, которое заменили на связь (from)-->(узел)-->(to)\n * */\n\n/** Вставляем фейковые узлы\n * @param edges - ребра\n * @param graph - граф\n * @param matrix - матрица с ячейками\n * @param processList - процесс */\nexport const insertFakeNodes = (edges: IEdge[], graph: IGraph, matrix: IMatrix, processList: number[]): IFakeResult => {\n  /** Копируем процесс */\n  const process: number[] = [...processList];\n  /** Индексы ребер, которые нужно удалить */\n  let indexesToRemove: Set<number> = new Set();\n  /** Таблица отслеживания путей. Нужно ддля последующей балансировки дерева. */\n  const pathMap: IPathMap = {};\n\n  /** Сортируем по длине ветки и Обходим все ребра и проверяем...*/\n  edges\n    .sort((e1: IEdge, e2: IEdge) => {\n      const delta1: number = Math.abs(graph[e1.from].y - graph[e1.to].y);\n      const delta2: number = Math.abs(graph[e2.from].y - graph[e2.to].y);\n      return delta1 - delta2;\n    })\n    .forEach((edge: IEdge, i: number) => {\n      let delta: number = graph[edge.from].y - graph[edge.to].y;\n      if (Math.abs(delta) > 1) {\n        /** Название пути */\n        const pathName: string = `${edge.from}=>${edge.to}`;\n\n        if (!pathMap[pathName]) {\n          pathMap[pathName] = new Set<number>();\n        }\n\n        /** Если ребро не соединяет соседние узлы процесса и ребро пересекает >1 уровня, вставляем фейковый узел */\n        const result = insertFakeNode(\n          edge.from,\n          edge.to,\n          graph,\n          edges,\n          i,\n          matrix,\n          delta,\n          indexesToRemove,\n          pathMap[pathName],\n          process\n        );\n\n        indexesToRemove = result.indexesToRemove;\n        matrix = result.matrix;\n      }\n    });\n\n  /** Конвертируем сет в массив и сортируем, чтобы при обходе не стереть нужное ребро */\n  const indexes: number[] = Array.from(indexesToRemove).sort((n: number, m: number) => n - m);\n  /** Удаляем ребра */\n  for (let i: number = indexes.length - 1; i >= 0; i--) {\n    edges.splice(indexes[i], 1);\n  }\n\n  return { edges, pathMap, process };\n};\n\n/** Вставляем фейковый узел\n * @param from - откуда идем\n * @param to - куда идем\n * @param graph - граф\n * @param edges - ребра\n * @param i - индекс последнего ребра, которое нужно удалить\n * @param matrix - матрица\n * @param delta - разница\n * @param indexesToRemove - индексы ребер, которые нужно удалить по окончании циклов\n * @param path - путь\n * @param process - процесс\n * */\nfunction insertFakeNode(\n  from: number,\n  to: number,\n  graph: IGraph,\n  edges: IEdge[],\n  i: number,\n  matrix: IMatrix,\n  delta: number,\n  indexesToRemove: Set<number>,\n  path: Set<number>,\n  process: number[]\n): {\n  indexesToRemove: Set<number>;\n  matrix: IMatrix;\n} {\n  /** Добавляем индексы для удаления */\n  indexesToRemove.add(i);\n\n  /** Добавляем узлы, которые не являются частью процесса, в путь */\n  if (graph[from].isProcess === 0) path.add(from);\n  if (graph[to].isProcess === 0) path.add(to);\n\n  /** Индекс последнего вставленного ребра в edges */\n  let insertedNodeIndex: number = -1;\n\n  /** Флаг процесса  */\n  const isProcess: boolean = process\n    .map((n: number, i: number) => `${n}=>${process[i + 1]}`)\n    .includes(`${from}=>${to}`);\n\n  /** Ищеем такой X, на котором можно провести вертикальную черту */\n  const desiredX: number = findDesiredX(from, to, graph, matrix);\n\n  /** Может показаться, что тут дублирование кода c findDesiredX. Но это не так.  */\n  const n1: IGraphNode = graph[from];\n  const n2: IGraphNode = graph[to];\n  const c: boolean = n1.y > n2.y;\n  let y: number = c ? n1.y - 1 : n1.y + 1;\n\n  /** Переопределяем from  */\n  let fromNode: number = from;\n\n  for (y; c ? y > n2.y : y < n2.y; c ? y-- : y++) {\n    /** Генерируем имя фейкового узла */\n    const name: number = hashNodeName(from, to, y);\n    path.add(name);\n\n    insertedNodeIndex = insertNode(graph, edges, name, y, desiredX, fromNode, to, isProcess, process);\n    indexesToRemove.add(insertedNodeIndex);\n    fromNode = name;\n  }\n\n  return {\n    indexesToRemove,\n    matrix: rearrangeMatrix(graph)\n  };\n}\n\n/** Функция хеширования названия фейкового узла\n * @param from - откуда идем\n * @param to - куда идем*\n * @param zeros - количетво нуле в имени\n * */\nfunction hashNodeName(from: number, to: number, zeros: number): number {\n  const s: string = new Array(zeros).fill('0').join('');\n  return -Math.abs(+`${to}${s}${from}`);\n}\n\n/** Добавляем узел\n * @param graph - граф\n * @param edges - ребра\n * @param name - имя фейкового узла\n * @param row - ряд\n * @param col - колонка\n * @param from - откуда идем\n * @param to - куда идем\n * @param isProcess - флаг процесса, добавляеся фейковым узлам на уровне 0\n * @param process - процесс\n */\nfunction insertNode(\n  graph: IGraph,\n  edges: IEdge[],\n  name: number,\n  row: number,\n  col: number,\n  from: number,\n  to: number,\n  isProcess: boolean,\n  process: number[]\n): number {\n  /** Создаем новый узел в графе */\n  graph[name] = {\n    children: [to],\n    x: col,\n    y: row,\n    parents: [from],\n    isProcess: isProcess ? 1 : 0,\n    processSibling: 0,\n    fake: 1,\n    css: {}\n  };\n\n  if (isProcess) {\n    /** Добавляем узел в процесс */\n    appendToProcess(to, name, process);\n  }\n\n  /** Добавляем name в дочерние узлы родителю и убираем непосредственную связь from - to */\n  graph[from] = {\n    ...graph[from],\n    children: [...graph[from].children.filter((n: number) => n !== to), name]\n  };\n\n  /** Добавляем name в родительские узлы последователю и убираем непосредственную связь from - to */\n  graph[to] = {\n    ...graph[to],\n    parents: [...graph[to].parents.filter((n: number) => n !== from), name]\n  };\n\n  /** Заменяем в массиве ребер текущее ребро двумя новыми */\n  edges.push({\n    from: from,\n    to: name\n  });\n  edges.push({\n    from: name,\n    to: to\n  });\n\n  return edges.length - 1;\n}\n\n/** Вставить фейковый узел в процесс\n * @param to - потомок\n * @param node - текущий фейковый узел\n * @param process - процесс\n */\nfunction appendToProcess(to: number, node: number, process: number[]) {\n  const index: number = process.indexOf(to);\n  if (index >= 0) {\n    process.splice(index, 0, node);\n  }\n}\n\n/** Между уровнями находим свободные ячейки, которые выстроены в одну вертикальную линию */\nfunction findDesiredX(from: number, to: number, graph: IGraph, matrix: IMatrix): number {\n  const n1: IGraphNode = graph[from];\n  const n2: IGraphNode = graph[to];\n\n  const c: boolean = n1.y > n2.y;\n\n  /** Начинаем со следующего уровня */\n  let y: number = c ? n1.y - 1 : n1.y + 1;\n\n  /** Желательная координата */\n  let x: number = Math.max(n1.x, n2.x);\n\n  /** Итерируем, пока не найдем свободный столбец */\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let columnIsEmpty: boolean = true;\n    for (y; c ? y > n2.y : y < n2.y; c ? y-- : y++) {\n      if (matrix[y][x] !== undefined) {\n        columnIsEmpty = false;\n        break;\n      }\n    }\n\n    if (columnIsEmpty) {\n      break;\n    }\n\n    x++;\n  }\n\n  return x;\n}\n","/** Балансировка графа */\nimport {\n  IBalanceResult, IGraph, IMap, IMatrix, INumberMap, IPathEntry, IPathMap \n} from './interfaces/interfaces';\nimport { rearrangeMatrix } from './rearrangeMatrix';\nimport { fillGaps } from './fillGaps';\n\n/** Результат проверки балансирвоки */\ninterface ICheckBalance {\n  /** Коэффициент баланса всех узлов (левые - правые) */\n  ratio: number;\n  /** Коэффициент баланса реальных узлов (левые - правые) */\n  realRatio: number;\n}\n\n/** Интерфейс, возвращаемый функцией processToMedian */\ninterface IMedianResult extends ICheckBalance {\n  /** Матрица узлов */\n  matrix: IMatrix;\n  /** Медиана матрицы, соответсует координате X процесса */\n  median: number;\n}\n\n/** Функция балансировки графа\n * @param graph - граф\n * @param matrix - матрица\n * @param process - узлы процесса */\nexport const balancing = (process: number[], graph: IGraph, matrix: IMatrix): IBalanceResult => {\n  /** Определить медиану */\n  let ptm: IMedianResult = processToMedian(graph, matrix);\n\n  /** Ищем ветки */\n  const pathMap: IPathMap = searchBranches(graph);\n\n  /** Пути, которые уже были перемещены */\n  const processedPaths: IMap<Set<number>> = {};\n\n  /** Перемещенные реальные узлы */\n  const processedNodes: IMap<boolean> = {};\n\n  /** Кеш средних значений X */\n  const averageXCache: INumberMap<number> = {};\n\n  /** Рекурсивная функция балансирвоки */\n  const recursiveBalancing = (graph: IGraph, matrix: IMatrix, pathMap: IPathMap) => {\n    /** Путь, который будет переброшен на левую сторону */\n    let pathToMove: IPathEntry | undefined;\n\n    /** Ищем путь, наиболее подходящий для перемещения в левую часть */\n    const paths: IPathEntry[] = Object.entries(pathMap);\n\n    /** Массив приближенности длины путей к количеству узлов, которые нужно перекинуть на левую сторону (ratio).\n     * Сортирвка сначала по realRatio, затем по координате Х, чтобы в вертикали граф был сбалансирован,\n     * затем по приближенности к ratio */\n    const approximations: number[][] = paths\n      .map((p: IPathEntry, i: number) => {\n        const delta: number = Math.abs(p[1].size - ptm.ratio);\n        const realNodes: number[] = Array.from(p[1]).filter((n: number) => !graph[n].fake);\n        const realDelta: number = Math.abs(realNodes.length - ptm.realRatio);\n        const averageX: number = averageXCache[+p[0]] || getBranchAverageX(p, graph, averageXCache);\n        return [delta, i, realDelta, averageX];\n      })\n      .sort((a1: number[], a2: number[]) => a1[2] - a2[2] || a1[0] - a2[0] || a2[3] - a1[3]);\n\n    if (approximations.length > 0) {\n      /** Порядковый номер пути */\n      const index: number = approximations[0][1];\n\n      /** Колбэк удаления pathToMove из списка путей */\n      const removePath = () => {\n        delete pathMap[paths[index][0]];\n      };\n\n      /** Количество уникальных сдвинутых путей. Если число не меняется, значит рекурсия  */\n      const pathsCount: number = Object.keys(processedPaths).length;\n\n      /** Определяем путь */\n      pathToMove = paths[index];\n      /** Сдвигаем путь на левую сторону */\n      if (!processedPaths[pathToMove[0]]) {\n        ptm = shiftToLeft(graph, pathToMove, ptm, processedPaths, processedNodes, removePath);\n      }\n\n      /** Если путь не испытан и есть новый путь, пробуем сдвинуть новый путь */\n      if (ptm.ratio > 0 && pathsCount !== Object.keys(processedPaths).length) {\n        recursiveBalancing(graph, ptm.matrix, pathMap);\n      }\n    }\n  };\n\n  recursiveBalancing(graph, matrix, pathMap);\n\n  /** Заполняем образовавшиеся пустоты */\n  fillGaps(graph, ptm.median);\n\n  return {\n    median: ptm.median,\n    matrix: rearrangeMatrix(graph)\n  };\n};\n\n/** Определить ширину графа и выставить процесс в x = медиана\n * @param graph\n * @param matrix */\nfunction processToMedian(graph: IGraph, matrix: IMatrix): IMedianResult {\n  let maxLengthRank: number = 0;\n  matrix.forEach((rank: (number | undefined)[]) => {\n    maxLengthRank = Math.max(rank.length, maxLengthRank);\n  });\n\n  /** Считаем медиану */\n  const median: number = maxLengthRank; // Math.ceil(maxLengthRank / 2);\n\n  /** Сдвигаем весь граф на +median */\n  for (const key in graph) {\n    graph[key].x = graph[key].x + median;\n  }\n\n  /** Перераспределяем узлы матрицы */\n  matrix = rearrangeMatrix(graph);\n\n  /** Считаем, в какую сторону добавить узлы */\n  const { ratio, realRatio }: ICheckBalance = checkBalance(matrix, median, graph);\n\n  return { ratio, realRatio, matrix, median };\n}\n\n/** Проверка сбалансированности графа\n * @param matrix - матрица\n * @param median - медиана матрицы\n * @param graph - граф */\nfunction checkBalance(matrix: IMatrix, median: number, graph: IGraph): ICheckBalance {\n  let left: number = 0;\n  let right: number = 0;\n\n  /** Количество реальных узлов слева и справа */\n  let leftRealNodes: number = 0;\n  let rightRealNodes: number = 0;\n\n  for (let i: number = 0; i < matrix.length; i++) {\n    for (let j: number = 0; j < matrix[i].length; j++) {\n      if (j === median) {\n        /** Пропускаем, если это узлы процесса */\n        continue;\n      }\n\n      /** Увеличиваем количество узлов слева или справа */\n      if (matrix[i][j] && j < median) {\n        left++;\n        if (!graph[matrix[i][j] as number].fake) {\n          leftRealNodes++;\n        }\n      }\n      if (matrix[i][j] && j > median) {\n        right++;\n        if (!graph[matrix[i][j] as number].fake) {\n          rightRealNodes++;\n        }\n      }\n    }\n  }\n\n  const ratio: number = Math.floor((right - left) / 2);\n  const realRatio: number = Math.floor((rightRealNodes - leftRealNodes) / 2);\n\n  /** Показатель сбалансированности. Если >0, то нужно перекинуть узлы на левую сторону */\n  return { ratio, realRatio };\n}\n\n/** Перемещение узлов на левую сторону\n * @param graph - граф\n * @param pathToMove - путь, который нужно переместить на левую сторону\n * @param ptm - объект с медианой, матрицей и ratio\n * @param processedPaths - пути, которые уже были испытаны\n * @param processedNodes - массив реальных узлов, которые были перемещены влево\n * @param cb - колбек при успешном сдвиге (удаление)\n */\nfunction shiftToLeft(\n  graph: IGraph,\n  pathToMove: IPathEntry,\n  ptm: IMedianResult,\n  processedPaths: IMap<Set<number>>,\n  processedNodes: IMap<boolean>,\n  cb: () => void\n): IMedianResult {\n  /** Помечаем путь как пройденный */\n  if (processedPaths[pathToMove[0]] === undefined) {\n    processedPaths[pathToMove[0]] = pathToMove[1];\n  }\n\n  /** Проходим по pathToMove[1] и исключаем уже обработанные узлы */\n  let processedCount: number = 0;\n  /** Количество реальных узлов, которые есть в ветке */\n  let realNodesCount: number = 0;\n\n  /** Флаг показаывает, произошел ли сдвиг */\n  let shifted: boolean = false;\n\n  /** Инвертируем координату X */\n  pathToMove[1].forEach((node: number) => {\n    if (!processedNodes[node]) {\n      processedCount++;\n\n      if (!graph[node].fake) {\n        realNodesCount++;\n      }\n    }\n\n    /** Если это реальный узел, стараемся прижать его к процессу. Иначе перекидываем диаметрально относительно медианы.\n     * Это нужно для того, чтобы граф не растягивался в ширину. */\n    if (!graph[node].fake) {\n      for (let i: number = ptm.median - 1; i >= 0; i--) {\n        if (ptm.matrix[graph[node].y][i] === undefined) {\n          graph[node].x = i;\n          ptm.matrix = rearrangeMatrix(graph);\n          break;\n        }\n      }\n    } else {\n      graph[node].x = ptm.median - (graph[node].x - ptm.median);\n    }\n\n    shifted = true;\n    processedNodes[node] = true;\n    cb();\n  });\n\n  return {\n    ...ptm,\n    matrix: rearrangeMatrix(graph),\n    ratio: shifted ? ptm.ratio - processedCount : ptm.ratio,\n    realRatio: shifted ? ptm.realRatio - realNodesCount : ptm.realRatio\n  };\n}\n\n/** Поиск веток. Ветка - это последовательность узлов от процесса к процессу\n * @param graph - граф\n */\nfunction searchBranches(graph: IGraph): IPathMap {\n  /** Таблица путей */\n  const pathMap: IPathMap = {};\n  /** Ветки */\n  const branches: IMap<boolean> = {};\n\n  /** Собираем пути от (процесса)=к=>(процессу) обходом вглубину */\n  const dfs = (node: number, acc: INumberMap<boolean>, from: number) => {\n    const path: string = Object.keys(acc).join('=>');\n    if (!branches[path] && path) {\n      branches[path] = true;\n    }\n\n    [...graph[node].parents, ...graph[node].children].forEach((n: number) => {\n      if (!acc[n] && !graph[n].isProcess) {\n        const path: string = Object.keys(acc).join('=>');\n        if (branches[path]) {\n          delete branches[path];\n        }\n        dfs(n, { ...acc, [n]: true }, from);\n      }\n    });\n  };\n\n  /** Обходом в ширину собираем все узлы вокруг реальных узлов, пока не дойдем до узлов процесса */\n  const bfs = (node: number): Set<number> => {\n    const branches: IMap<number[]> = {};\n    const stack: number[] = [node];\n\n    while (stack.length) {\n      const c = stack.pop() as number;\n\n      if (!branches[c]) {\n        branches[c] = [];\n      }\n\n      [...graph[c].children, ...graph[c].parents].forEach((n: number) => {\n        if (!branches[n] && !graph[n].isProcess) {\n          stack.push(n);\n        }\n        if (!graph[n].isProcess) {\n          branches[c].push(n);\n        }\n      });\n    }\n\n    const values: number[] = Object.values(branches).reduce((acc: number[], e: number[]) => [...acc, ...e], []);\n    return new Set(values);\n  };\n\n  /** Обходим граф. DFS собирает отдельные ветки. BFS собирает кластеры. */\n  for (const key in graph) {\n    if (graph[key].isProcess) {\n      dfs(+key, {}, +key);\n    }\n\n    if (!graph[key].isProcess && !graph[key].fake) {\n      pathMap[`${key}`] = bfs(+key);\n    }\n  }\n\n  /** Собираем PathMap на основе веток */\n  const keys: string[] = Object.keys(branches);\n\n  keys.forEach((branch: string) => {\n    const path: string[] = branch.split('=>');\n    const from = path[0];\n    const to = path[path.length - 1];\n\n    /** Из того, что собрал DFS, забираем только ветки из фейковых узлов. */\n    if (graph[+from].fake) {\n      pathMap[`${from}=>${to}`] = new Set(path.map((n: string) => +n));\n    }\n  });\n\n  /** Сравниваем ветки */\n  const compareSets = (s1: Set<number>, s2: Set<number>) => {\n    if (s1.size !== s2.size) return false;\n    return Array.from(s1).sort().join('') === Array.from(s2).sort().join('');\n  };\n\n  /** После BFS и DFS могут быть одинаковые ветки, так как узлы связаны между собой. Их нужно исключить. */\n  const entries: [string, Set<number>][] = Object.entries(pathMap);\n  for (let i: number = 0; i < entries.length; i++) {\n    for (let j: number = i + 1; j < entries.length; j++) {\n      if (compareSets(entries[i][1], entries[j][1])) {\n        delete pathMap[entries[i][0]];\n      }\n    }\n  }\n\n  return pathMap;\n}\n\n/** Средняя координата X ветки */\nfunction getBranchAverageX(branch: IPathEntry, graph: IGraph, averageXCache: INumberMap<number>) {\n  let avgX: number = 0;\n\n  branch[1].forEach((n: number) => {\n    avgX += graph[n].x;\n  });\n\n  averageXCache[+branch[0]] = Math.round(avgX / branch[1].size);\n  return averageXCache[+branch[0]];\n}\n","import intersect from 'path-intersection';\n/** Рисуем ребра */\nimport {\n  IColors,\n  IConfig,\n  IEdge,\n  IGraph,\n  IGraphNode,\n  ILines,\n  IMap,\n  INodeMetrics,\n  IPathMap,\n  IRect\n} from './interfaces/interfaces';\nimport * as d3 from 'd3';\n\ntype FourNumber = [number, number, number, number];\n\ninterface ICoordsResult {\n  points: IMap<[number, number][]>;\n  metricsCoords: FourNumber[];\n}\n\nexport const drawEdges = (\n  edges: IEdge[],\n  graph: IGraph,\n  pathMap: IPathMap,\n  process: number[],\n  scene: HTMLDivElement,\n  config: IConfig\n): ILines => {\n  /** Таблица путей для константного доступа */\n  const lines: ILines = {};\n\n  if (scene) {\n    /** Ищем на сцене svg и удаляем его, чтобы при повторном рендере svg не наложились друг на друга */\n    const svgElement = scene.querySelector('svg');\n    if (svgElement) {\n      scene.removeChild(svgElement);\n    }\n\n    /** Определяем максимальную координату X для определения ширины сцены */\n    let maxX: number = Number.MIN_SAFE_INTEGER;\n    Object.values(graph).forEach((v: IGraphNode) => {\n      maxX = Math.max(maxX, v.css.translate.x);\n    });\n\n    /** Отступ от правого края экрана */\n    const paddingRight: number = 20;\n\n    maxX = Math.max(maxX + paddingRight, scene.scrollWidth);\n\n    // const layer = scene.firstElementChild;\n    const svg = d3.select(scene).append('svg').attr('width', maxX).attr('height', scene.scrollHeight);\n\n    const { points, metricsCoords }: ICoordsResult = getCoords(graph, pathMap, edges, config.rect);\n\n    for (const path in points) {\n      let coords: [number, number][] = points[path];\n\n      /** ID узла, куда приходит линия */\n      const [from, to]: string[] = path.split('=>');\n\n      /** Функция кривой */\n      const curve = from === to ? d3.curveBasis : d3.curveMonotoneY;\n\n      /** Кривая Безье */\n      const l = d3\n        .line()\n        .x((d) => d[0])\n        .y((d) => d[1])\n        .curve(curve);\n\n      /** Флаг процесса  */\n      const isProcess: boolean =\n        from !== to && process.map((n: number, i: number) => `${n}=>${process[i + 1]}`).includes(path);\n\n      /** Линия неактвина */\n      let disabled: boolean = false;\n\n      /** Ребро */\n      const edge: IEdge | undefined = edges.find((e: IEdge) => e.from === +from && e.to === +to);\n      if (edge && edge.status && edge.status === 'disabled') {\n        disabled = true;\n      }\n\n      /** Путь */\n      const pathElement = drawPath(svg, l(coords), path, isProcess, disabled, config.colors);\n\n      /** Рисуем в этом узле SVG Path размером с узел */\n      const toPath: SVGPathElement = appendOverlayRect(graph, +to, svg) as SVGPathElement;\n\n      /** Ищем пересечения пути ребра и пути узла */\n      const intersection = intersect(\n        // @ts-ignore\n        pathElement.getAttribute('d'),\n        // @ts-ignore\n        toPath.getAttribute('d')\n      );\n\n      if (intersection.length > 0) {\n        /** Удаляем последние координаты (координаы узла) */\n        coords.pop();\n        /** Добавляем координаты точки пересечения */\n        coords.push([intersection[0].x, intersection[0].y]);\n        /** Стираем линию */\n        pathElement.remove();\n\n        /** Заново отрисовываем линию */\n        const line = drawPath(svg, l(coords), path, isProcess, disabled, config.colors);\n        lines[path] = {\n          line,\n          disabled,\n          color: {\n            default: disabled ? config.colors.disabled : config.colors.primary,\n            hover: config.colors.hover\n          },\n          marker: {\n            default: disabled ? config.markers.disabled : config.markers.primary,\n            hover: config.markers.hover\n          }\n        };\n      }\n    }\n\n    /** Создаем стрелки */\n    createMarker(svg, config.colors.primary, config.markers.primary);\n    createMarker(svg, config.colors.disabled, config.markers.disabled);\n    createMarker(svg, config.colors.hover, config.markers.hover);\n    /** Вставляем метрики */\n    insertMetrics(metricsCoords, edges, svg);\n  }\n\n  return lines;\n};\n\n/** Считаем координаты */\nfunction getCoords(graph: IGraph, pathMap: IPathMap, edges: IEdge[], rect: IRect): ICoordsResult {\n  let coords: IMap<[number, number][]> = {};\n\n  /** Массив координат для метрик */\n  const metricsCoords: FourNumber[] = [];\n\n  /** Обработка длинных путей между реальными и фейковыми узлами */\n  for (const key in pathMap) {\n    const [from, to] = key.split('=>');\n    coords[key] = [];\n    coords[key].push(calculateCoords(graph[+from]));\n\n    const paths: number[] = Array.from(pathMap[key]);\n    /** Координата метрики уже добавлена */\n    let metricInserted: boolean = false;\n\n    for (let i: number = 0; i < paths.length; i++) {\n      if (paths[i] === +from || paths[i] === +to) {\n        continue;\n      }\n      const c: [number, number] = calculateCoords(graph[paths[i]]);\n      if (!metricInserted) {\n        metricsCoords.push([c[0], c[1], +from, +to]);\n        metricInserted = true;\n      }\n      coords[key].push(c);\n    }\n\n    coords[key].push(calculateCoords(graph[+to]));\n  }\n\n  /** Обработка коротких путей между реальными узлами */\n  edges.forEach((edge: IEdge) => {\n    const id: string = `${edge.from}=>${edge.to}`;\n    /** Если есть обратный id, это значит, что ребра наложатся друг на друга. Следовательно,\\\n     * нужно добавить третью точку немного в стороне, чтобы одно из ребер ушло в бок */\n    const reverseId: string = `${edge.to}=>${edge.from}`;\n\n    if (coords[id] === undefined && !graph[edge.from].fake && !graph[edge.to].fake) {\n      /** Первая точка */\n      const first: [number, number] = calculateCoords(graph[edge.from]);\n      /** Последняя точка */\n      const last: [number, number] = calculateCoords(graph[edge.to]);\n\n      /** Отступ по X от схожей линии */\n      let deltaX: number = 0;\n      /** Отступ по Y от схожей линии */\n      let deltaY: number = 0;\n      /** Промежуточная точка. Она же является координатой для количества переходов (метрики) */\n      let mid: [number, number];\n\n      /** Проверяем, есть ли ребро с такими же координатами */\n      if (coords[reverseId]) {\n        deltaX = 35;\n      }\n\n      /** Если from и to это одна и та же точка, то создаем петлю в правом верхнем углу */\n      if (edge.from === edge.to) {\n        deltaX = 10;\n        deltaY = 10;\n\n        first[0] += rect.width / 2;\n        first[1] -= rect.height / 2;\n        /** X второй точки сдвигаем влево, чтобы стрелка не наложилась на ребро */\n        last[0] += rect.width / 2 - deltaX;\n        last[1] -= rect.height / 2;\n\n        /** Переопределяем для правильного расчета mid точки */\n        deltaX -= deltaX / 2;\n      }\n\n      mid = [(first[0] + last[0]) / 2 + deltaX, (first[1] + last[1]) / 2 - deltaY];\n      metricsCoords.push([mid[0], mid[1], edge.from, edge.to]);\n      coords[id] = [first, mid, last];\n    }\n  });\n\n  return {\n    points: coords,\n    metricsCoords\n  };\n}\n\n/** Пересчет координаты */\nfunction calculateCoords(node: IGraphNode): [number, number] {\n  return [node.css.translate.x + node.css.width / 2, node.css.translate.y + node.css.height / 2];\n}\n\n/** Добавляем подложки под узлы, чтобы считать пересечения с ребрами */\nfunction appendOverlayRect(graph: IGraph, node: number, svg: any): SVGPathElement {\n  const c: IGraphNode = graph[node];\n\n  /** Radius = 8. Разница в 2, чтобы кончик стрелки не затуплялся */\n  const d: string = `M ${c.css.translate.x + 7} ${c.css.translate.y - 2} h ${c.css.width - 14}\n    a8,8 0 0 1 8,8 v ${c.css.height - 12.5} \n    a8,8 0 0 1 -8,8 H ${c.css.translate.x + 7} \n    a8,8 0 0 1 -8,-8 V ${c.css.translate.y + 6} \n    a8,8 0 0 1 8,-8 z`;\n\n  // `M ${c.css.translate.x} ${c.css.translate.y} h ${c.css.width} v ${c.css.height}\n  //         H ${c.css.translate.x} Z`\n\n  const path = svg\n    .append('path')\n    .attr('d', d)\n    .attr('id', `rect-${node}`)\n    .style('stroke', 'transparent')\n    .style('fill', 'transparent')\n    .style('stroke-width', '1px');\n\n  return path._groups[0][0];\n}\n\n/** Создать маркер */\nfunction createMarker(svg: any, color: string, id: string) {\n  svg\n    .append('defs')\n    .append('marker')\n    .attr('id', id)\n    .attr('viewBox', '0 0 5 5')\n    .attr('refX', '4')\n    .attr('refY', '2.5')\n    .attr('markerUnits', 'strokeWidth')\n    .attr('markerWidth', '5')\n    .attr('markerHeight', '5')\n    .attr('orient', 'auto')\n    .attr('fill', color)\n    .append('path')\n    .attr('d', 'M 0 0 L 5 2.5 L 0 5 z')\n    .append('path');\n}\n\n/** Вставляем метрики */\nfunction insertMetrics(metricsCoords: FourNumber[], edges: IEdge[], svg: any) {\n  /** Таблица для O(1) поиска */\n  const map: IMap<number> = edges.reduce((acc: IMap<number>, edge: IEdge, i: number) => {\n    const id: string = `${edge.from}=>${edge.to}`;\n    if (acc[id] === undefined) {\n      acc[id] = i;\n    }\n    return acc;\n  }, {});\n\n  metricsCoords.forEach((m: FourNumber) => {\n    /** Ищем нужное ребром from-to в массиве edges */\n    const index: number = map[`${m[2]}=>${m[3]}`]; // edges.findIndex((e: IEdge) => e.from === m[2] && e.to === m[3]);\n    const count: number | undefined = edges[index].metrics ? +(edges[index].metrics as INodeMetrics).count : undefined;\n\n    svg\n      .append('text')\n      .attr(\n        'class',\n        `graph__edge-count \n      ${edges[index].status && edges[index].status === 'disabled' ? 'graph__edge-count--disabled' : ''}`\n      )\n      .attr('x', m[0] + 2) // + 2px, чтобы не налезало на линию\n      .attr('y', m[1])\n      .text(count);\n  });\n}\n\n/** Отрисовка линии */\nfunction drawPath(\n  svg: any,\n  lineGenerator: string | null,\n  id: string,\n  isProcess: boolean,\n  disabled: boolean,\n  colors: IColors\n): SVGPathElement {\n  const path = svg\n    .append('path')\n    // @ts-ignore\n    .attr('id', id)\n    .attr('d', lineGenerator)\n    .style('fill', 'none')\n    .style('stroke', disabled ? colors.disabled : colors.primary)\n    .style('stroke-width', isProcess ? '3px' : '1px')\n    .attr('marker-end', `url(#${disabled ? 'marker-arrow--disabled' : 'marker-arrow'})`);\n\n  return path._groups[0][0];\n}\n","import {\n  IGraph, IMatrix, IPathEntry, IPathMap, IRect \n} from './interfaces/interfaces';\nimport { rearrangeMatrix } from './rearrangeMatrix';\n\n/** Стягиваем фейковые узлы, чтобы они не растягивали экран\n * @param graph - граф\n * @param median - медиана\n * @param rect - базовые размеры узлов\n * @param pathMap - ветки\n */\nexport const translateFakeNodes = (\n  graph: IGraph,\n  median: number,\n  rect: IRect,\n  pathMap: IPathMap\n): {\n  median: number;\n  paths: IPathEntry[][];\n} => {\n  let matrix: IMatrix = rearrangeMatrix(graph);\n\n  /** [1] Разделяем ветки на левые и правые. Те, которые пересекают медиану, не трогаем */\n  const leftPaths: IPathMap = {};\n  const rightPaths: IPathMap = {};\n\n  Object.keys(pathMap).forEach((key: string) => {\n    const array: number[] = Array.from(pathMap[key]);\n\n    /** Так как могуть быть ветки, пересекающие медиану, нужно проверить и right и left */\n    const right: boolean = array.every((n: number) => graph[n].x > median);\n    const left: boolean = array.every((n: number) => graph[n].x < median);\n\n    if (right) rightPaths[key] = pathMap[key];\n    if (left) leftPaths[key] = pathMap[key];\n  });\n\n  /** [2] Сортируем по координате X */\n  const leftEntries: IPathEntry[] = Object.entries(leftPaths);\n  const rightEntries: IPathEntry[] = Object.entries(rightPaths);\n\n  /** Функция сдвига */\n  const shift = (x: number, path: number[]) => {\n    let valid: boolean = true;\n    for (let i: number = 0; i < path.length; i++) {\n      if (!graph[path[i]].fake) {\n        continue;\n      }\n\n      const y: number = graph[path[i]].y;\n      valid = matrix[y][x] === undefined || (matrix[y][x] !== undefined && path.indexOf(matrix[y][x] as number) >= 0);\n\n      if (!valid) {\n        break;\n      }\n    }\n\n    if (valid) {\n      for (let i: number = 0; i < path.length; i++) {\n        if (graph[path[i]].fake) {\n          graph[path[i]].x = x;\n        }\n      }\n\n      matrix = rearrangeMatrix(graph);\n    }\n  };\n\n  /** [3] Левая сторона */\n  leftEntries.forEach((e: IPathEntry) => {\n    const path: number[] = Array.from(e[1]);\n    let x: number = Number.MAX_SAFE_INTEGER;\n\n    path.forEach((n: number) => {\n      x = Math.min(graph[n].x, x);\n    });\n\n    for (x; x < median; x++) {\n      shift(x, path);\n    }\n  });\n\n  /** [4] Правая сторона */\n  rightEntries.forEach((e: IPathEntry) => {\n    const path: number[] = Array.from(e[1]);\n    let x: number = Number.MIN_SAFE_INTEGER;\n\n    path.forEach((n: number) => {\n      x = Math.max(graph[n].x, x);\n    });\n\n    for (x; x > median; x--) {\n      shift(x, path);\n    }\n  });\n\n  /** [5] Сдвигаем координату всех элементов */\n  const keys: string[] = Object.keys(graph);\n\n  let min: number = Number.MAX_SAFE_INTEGER;\n  keys.forEach((n: string) => {\n    min = Math.min(min, graph[+n].x);\n  });\n\n  keys.forEach((n: string) => {\n    graph[+n].x -= min;\n  });\n\n  const newMedian: number = median - min;\n\n  return {\n    median: newMedian,\n    paths: [leftEntries, rightEntries]\n  };\n};\n","import {\n  IBalanceResult,\n  IColors,\n  IConfig,\n  IEdge,\n  IFakeResult,\n  IGraph,\n  IGraphData,\n  IGraphResult,\n  ILines,\n  IMarkers,\n  IMatrix,\n  IPathMap,\n  IRect\n} from './interfaces/interfaces';\nimport { createGraph } from './createGraph';\nimport { ranking } from './ranking';\nimport { ordering } from './ordering';\nimport { insertFakeNodes } from './insertFakeNodes';\nimport { balancing } from './balancing';\n\nimport { drawEdges } from './drawEdges';\nimport { translateFakeNodes } from './translateFakeNodes';\nimport { detectStartEnd } from './detectStartEnd';\nimport { createNodes } from './createNodes';\nimport { stickToLeft } from './stickToLeft';\nimport { rearrangeMatrix } from './rearrangeMatrix';\nimport { shrinkFakeNodes } from './shrinkFakeNodes';\n\nexport class LayeredGraph {\n  /** Граф */\n  public graph: IGraph = {};\n  /** Матрица */\n  public matrix: IMatrix = [];\n  /** Медиана */\n  public median: number = 0;\n  /** Процесс */\n  public process: number[] = [];\n  /** Начало процесса */\n  public start: number = -1;\n  /** Конец процесса */\n  public end: number = -1;\n  /** Сцена */\n  public scene: HTMLDivElement | null = null;\n  /** Таблица путей */\n  public pathMap: IPathMap = {};\n  /** Ребра */\n  public edges: IEdge[] = [];\n\n  /** Стандартные размеры блоков */\n  public rect: IRect = {\n    width: 176,\n    height: 46,\n    gap: 50,\n    fakeWidth: 20\n  };\n\n  /** Цветовое оформление */\n  public colors: IColors = {\n    primary: '#A5BFDD',\n    hover: '#2E89BA',\n    disabled: '#E5E5E5'\n  };\n\n  /** Маркеры */\n  public markers: IMarkers = {\n    primary: 'marker-arrow',\n    hover: 'marker-arrow--hover',\n    disabled: 'marker-arrow--disabled'\n  };\n\n  /** Конфиг визуалки */\n  public config: IConfig = {\n    rect: this.rect,\n    colors: this.colors,\n    markers: this.markers\n  };\n\n  constructor(public data: IGraphData) {}\n\n  /** Инициализируем граф */\n  public init(): IGraphResult {\n    if (this.data.paths.length === 0) {\n      return {\n        nodes: [],\n        graph: {}\n      };\n    }\n\n    /** [1] Создаем структуру графа */\n    this.graph = createGraph(this.data);\n\n    /** [2] Определяем стартовую и конечную координаты */\n    const startEnd: number[] = detectStartEnd(this.data.nodes, this.graph);\n    this.start = startEnd[0];\n    this.end = startEnd[1];\n\n    this.process = [this.start, ...this.data.paths[0].path, this.end];\n    this.edges = [...this.data.edges];\n\n    /** [3] Распределяем узлы по вертикали */\n    this.matrix = ranking(this.data, this.graph, this.process);\n\n    /** [4] Распределяем узлы по горизонтали */\n    this.matrix = ordering(this.graph, this.matrix, this.end);\n\n    /** [5] Вставляем фейковые узлы */\n    const fakes: IFakeResult = insertFakeNodes(this.edges, this.graph, this.matrix, this.process);\n    this.pathMap = fakes.pathMap;\n    this.matrix = rearrangeMatrix(this.graph);\n\n    /** [6] Балансировка */\n    const balance: IBalanceResult = balancing(this.process, this.graph, this.matrix);\n    this.median = balance.median;\n    this.matrix = balance.matrix;\n\n    /** [7] Уменьшаем количество пересечений */\n    // this.matrix = crossingMinimization(this.graph, this.matrix, this.median);\n\n    /** [8] Убираем гэпы */\n    const tfn = translateFakeNodes(this.graph, this.median, this.rect, this.pathMap);\n    this.median = tfn.median;\n\n    /** [9] Создаем массив узлов с координатами */\n    const nodes: any = createNodes(this.graph, this.data, this.rect);\n\n    /** [10] Сжимаем фейковые узлы */\n    shrinkFakeNodes(tfn.paths, this.rect, this.graph, this.median);\n\n    /** [11] Убираем пустые ячейки слева */\n    stickToLeft(this.graph);\n\n    this.matrix = rearrangeMatrix(this.graph);\n\n    console.log('%c Данные', 'color: #6ff9ff');\n    console.log(this.data);\n    console.log('%c -------------------', 'color: #6ff9ff');\n\n    console.log('%c Граф', 'color: #98ee99');\n    console.log(this.graph);\n    console.log('%c -------------------', 'color: #98ee99');\n\n    console.log('%c Матрица', 'color: #ffe54c');\n    console.log(this.matrix);\n    console.log('%c -------------------', 'color: #ffe54c');\n\n    return {\n      nodes,\n      graph: this.graph\n    };\n  }\n\n  /** [11] Рисуем ребра */\n  public drawEdges(scene: HTMLDivElement): ILines {\n    this.scene = scene;\n    return drawEdges(this.data.edges, this.graph, this.pathMap, this.process, this.scene, this.config);\n  }\n\n  /** Перерисовка смежных ребер при перемещении узла */\n  public moveNode(id: number, x: number, y: number) {\n    console.log(id, x, y);\n    this.graph[id].css.translate.x = x;\n    this.graph[id].css.translate.y = y;\n    if (this.scene) {\n      drawEdges(this.data.edges, this.graph, this.pathMap, this.process, this.scene, this.config);\n    }\n  }\n}\n","import { IEdge, IGraph, IGraphData } from './interfaces/interfaces';\n\n/** Создаем структуру графа\n * @param data - узлы, ребра и пути в графе */\nexport const createGraph = (data: IGraphData): IGraph => {\n  /** Граф */\n  const graph: IGraph = {};\n  /* шаблон узла*/\n  const baseNode: string = `{\n    \"children\": [],\n    \"x\": 0,\n    \"y\": 0,\n    \"parents\": [],\n    \"isProcess\": 0,\n    \"processSibling\": 0,\n    \"fake\": 0,\n    \"css\": {}\n  }`;\n  /** Добавляем узлы в граф  */\n  data.edges.forEach((edge: IEdge) => {\n    [edge.from, edge.to].forEach((edge: number) => {\n      graph[edge] === undefined && (graph[edge] = JSON.parse(baseNode));\n    });\n    /** Добавляем родительские узлы потомкам */\n    graph[edge.to].parents.push(edge.from);\n    /** Узлам, у которых есть потомки, добавляем в edges список потомков */\n    graph[edge.from].children.push(edge.to);\n  });\n  return graph;\n};\n","import { IGraph, INode } from './interfaces/interfaces';\n/*  бежим по нодам находим type  и складываем начало и конец в массив results  также продолжаем\n *   размечать граф добавлея конечный и начальный узел в его структуре\n * */\nexport const detectStartEnd = (nodes: INode[], graph: IGraph): number[] => {\n  const result: number[] = [];\n\n  for (let i: number = 0; i < nodes.length; i++) {\n    if (nodes[i].type?.toLowerCase() === 'start') {\n      result[0] = i;\n      graph[i].type = 'start';\n    }\n\n    if (nodes[i].type?.toLowerCase() === 'end') {\n      result[1] = i;\n      graph[i].type = 'end';\n    }\n\n    if (result.length === 2) {\n      break;\n    }\n  }\n\n  return result;\n};\n","import {\n  IGraph, IGraphData, INode, INodeElement, INodeMetrics, IRect \n} from './interfaces/interfaces';\n\n/** Создаем массив узлов с координатами\n * @param graph - граф\n * @param data - данные графа\n * @param rect - базовые размеры узлов\n */\nexport const createNodes = (graph: IGraph, data: IGraphData, rect: IRect): INodeElement[] => {\n  /** Медиана зацикленности */\n  const c: number[] = data.nodes.reduce((acc: number[], n: INode) => {\n    if (n.metrics) {\n      acc.push(+n.metrics.cycling);\n    }\n    return acc;\n  }, []);\n  c.sort();\n  const mCycling: number = c[Math.floor(c.length / 2)];\n\n  return Object.keys(graph).map((n: string) => {\n    graph[+n].css = {\n      width: graph[+n].css.width || rect.width,\n      height: graph[+n].css.height || rect.height,\n      translate: {\n        x: graph[+n].css.translate?.x || graph[+n].x * (rect.width + rect.gap),\n        y: graph[+n].css.translate?.y || graph[+n].y * (rect.height + rect.gap)\n      }\n    };\n\n    let isCyclingOk: boolean = true;\n    if (data.nodes[+n] && data.nodes[+n].metrics) {\n      isCyclingOk = (data.nodes[+n].metrics as INodeMetrics).cycling < mCycling + 0.1 * mCycling;\n    }\n\n    return {\n      name: n,\n      node: data.nodes[+n],\n      x: graph[+n].x,\n      y: graph[+n].y,\n      process: graph[+n].isProcess,\n      fake: graph[+n].fake,\n      css: graph[+n].css,\n      isCyclingOk\n    };\n  });\n};\n","import { IGraph, IMatrix, IPathEntry, IRect } from './interfaces/interfaces';\nimport { rearrangeMatrix } from './rearrangeMatrix';\n\n/** Ищем минимальную и максимальную координаты реальных узлов.\n * Все фейковые узлы, которые находятся дальше этих координат, сжимаются.  */\nexport const shrinkFakeNodes = (paths: IPathEntry[][], rect: IRect, graph: IGraph, median: number) => {\n  let matrix: IMatrix = rearrangeMatrix(graph);\n\n  /** Минимальная и максимальная координаты реальных узлов */\n  let min: number = Number.MAX_SAFE_INTEGER;\n  let max: number = Number.MIN_SAFE_INTEGER;\n\n  matrix.forEach((row: (number | undefined)[]) => {\n    row.forEach((n: number | undefined) => {\n      if (n !== undefined && !graph[n].fake) {\n        min = Math.min(min, graph[n].x);\n        max = Math.max(max, graph[n].x);\n      }\n    });\n  });\n\n  /** Левая сторона */\n  const left: number[][] = paths[0]\n    .map((e: IPathEntry) => Array.from(e[1]).filter((n: number) => graph[n].fake && graph[n].x < min))\n    .filter((e: number[]) => e.length)\n    .sort((a: number[], b: number[]) => graph[b[0]].x - graph[a[0]].x);\n\n  let x: number = min;\n\n  left.forEach((nodes: number[]) => {\n    nodes.forEach((n: number) => {\n      if (graph[n].x !== x) {\n        x = graph[n].x;\n      }\n\n      graph[n].css.width = rect.fakeWidth;\n      graph[n].css.translate.x += (rect.width - rect.fakeWidth) * (min - x);\n    });\n  });\n\n  /** Правая сторона */\n  const right: number[][] = paths[1]\n    .map((e: IPathEntry) => Array.from(e[1]).filter((n: number) => graph[n].fake && graph[n].x > max))\n    .filter((e: number[]) => e.length)\n    .sort((a: number[], b: number[]) => graph[a[0]].x - graph[b[0]].x);\n\n  x = max;\n\n  right.forEach((nodes: number[]) => {\n    nodes.forEach((n: number) => {\n      if (graph[n].x !== x) {\n        x = graph[n].x;\n      }\n\n      graph[n].css.width = rect.fakeWidth;\n\n      if (x > max) {\n        graph[n].css.translate.x -= (rect.width - rect.fakeWidth) * (x - max - 1);\n      }\n    });\n  });\n};\n","import { IGraph } from './interfaces/interfaces';\n\n/** Прижимаем граф после всех трансформаций к левому краю\n * @param graph - граф\n */\nexport const stickToLeft = (graph: IGraph) => {\n  /** [1] Ищем минимиальную координату Х */\n  let minX: number = Number.MAX_SAFE_INTEGER;\n\n  const keys: string[] = Object.keys(graph);\n\n  keys.forEach((key: string) => {\n    minX = Math.min(minX, graph[+key].css.translate.x);\n  });\n\n  /** [2] Двигаем все узлы влево на minX */\n  keys.forEach((key: string) => {\n    graph[+key].css.translate.x -= minX;\n  });\n};\n","import React from 'react';\nimport './GraphNode.scss';\n\ninterface IProps {\n  item: any;\n}\n\nconst GraphNode: React.FC<IProps> = ({ item }) => {\n  /** Класс для зацикленности */\n  const cyclingClass: string = item.isCyclingOk ? 'content-metrics__cycling--good' : 'content-metrics__cycling--bad';\n\n  return (\n    <div className={`node__content ${item.node.type ? 'node__content--bounds' : ''}`}>\n      {item.node.type ? (\n        <>{item.node.type.toLowerCase() === 'start' ? 'Начало процесса' : 'Конец процесса'}</>\n      ) : (\n        <>\n          {item.node.metrics && (\n            <div className='node__content-metrics'>\n              <div className='content-metrics__count'>{item.node.metrics.count}</div>\n              {!!item.node.metrics.cycling && (\n                <div className={`content-metrics__cycling ${cyclingClass}`}>{item.node.metrics.cycling}%</div>\n              )}\n            </div>\n          )}\n          <div className='node__content-description'>\n            <p className='node__content-name'>{item.node.name.toLowerCase()}</p>\n            {/*<p className='node__content-name'>{item.name}</p>*/}\n          </div>\n        </>\n      )}\n    </div>\n  );\n};\n\nexport default GraphNode;\n","import Graph from './Graph';\n\nexport default Graph;\n","import React, { useEffect, useRef, useState } from 'react';\nimport './Graph.scss';\nimport { IGraphData, IGraphResult, ILines, INodeElement } from '../LayeredGraph/interfaces/interfaces';\nimport { LayeredGraph } from '../LayeredGraph';\nimport GraphNode from '../GraphNode/GraphNode';\n\ninterface IProps {\n  data: IGraphData;\n}\n\nconst Graph: React.FC<IProps> = ({ data }) => {\n  /** Сцена */\n  const scene = useRef<HTMLDivElement>(null);\n  /** Граф */\n  const [graph, setGraph] = useState<LayeredGraph>();\n  /** Узлы */\n  const [nodes, setNodes] = useState<INodeElement[]>([]);\n  /** Табл */\n  const lines = useRef<ILines>({});\n\n  /** Текущие координаты сцены */\n  const currentCoords = useRef<{ left: number; top: number }>({ left: 0, top: 0 });\n\n  // -------------------------------------------------------------------------------------------------------------------\n\n  /** Отрисовка ребер после отрисовки узлов */\n  useEffect(() => {\n    if (scene.current && nodes.length > 0 && graph) {\n      lines.current = graph.drawEdges(scene.current);\n    }\n  }, [scene, nodes, graph]);\n\n  // -------------------------------------------------------------------------------------------------------------------\n\n  /** Инициализируем граф */\n  useEffect(() => {\n    const graph = new LayeredGraph(data);\n    const { nodes }: IGraphResult = graph.init();\n    setGraph(graph);\n    setNodes(nodes);\n  }, [data]);\n\n  // -------------------------------------------------------------------------------------------------------------------\n\n  /** Флаг движения */\n  const dragging = useRef<boolean>(false);\n  /** Узел, который будем двигать */\n  const draggingNode = useRef<any>(null);\n\n  /** Зажали мышь и начинаем движение */\n  const onMouseDown = (e: React.MouseEvent) => {\n    // dragging.current = true;\n    draggingNode.current = e.currentTarget as HTMLDivElement;\n  };\n\n  /** Отпустили мышь и заканчиваем движение */\n  const onMouseUp = () => {\n    dragging.current = false;\n    draggingNode.current = null;\n  };\n\n  const onMouseMove = (e: React.MouseEvent | MouseEvent) => {\n    if (draggingNode.current && dragging.current) {\n      e.stopPropagation();\n      const x = e.clientX - draggingNode.current.offsetWidth / 2 - currentCoords.current.left;\n      const y = e.clientY - draggingNode.current.offsetHeight / 2 - currentCoords.current.top;\n      draggingNode.current.style.transform = `translate(${x}px, ${y}px)`;\n    }\n  };\n\n  /** Добавляем движение узла в window */\n  useEffect(() => {\n    window.addEventListener('mouseup', onMouseUp);\n    window.addEventListener('mousemove', onMouseMove);\n\n    return () => {\n      window.removeEventListener('mouseup', onMouseUp);\n      window.removeEventListener('mousemove', onMouseMove);\n    };\n  }, []);\n\n  // -------------------------------------------------------------------------------------------------------------------\n\n  /** Изменияем цвет линий на ховере */\n  const onMouseEnter = (e: React.MouseEvent) => {\n    const el = e.currentTarget as HTMLDivElement;\n    Object.keys(lines.current).forEach((key: string) => {\n      const tmp: string[] = key.split('=>');\n      if (tmp.includes(el.id) && !lines.current[key].disabled) {\n        lines.current[key].line.style.stroke = lines.current[key].color.hover;\n        lines.current[key].line.setAttribute('marker-end', `url(#${lines.current[key].marker.hover})`);\n      }\n    });\n  };\n\n  /** Сбарсываем ховер */\n  const onMouseLeave = (e: React.MouseEvent) => {\n    const el = e.currentTarget as HTMLDivElement;\n    Object.keys(lines.current).forEach((key: string) => {\n      const tmp: string[] = key.split('=>');\n      if (tmp.includes(el.id)) {\n        lines.current[key].line.style.stroke = lines.current[key].color.default;\n        lines.current[key].line.setAttribute('marker-end', `url(#${lines.current[key].marker.default})`);\n      }\n    });\n  };\n\n  // -------------------------------------------------------------------------------------------------------------------\n\n  /** Выводим узлы на экран */\n  const nodesJSX = nodes.map((n: any) => {\n    return (\n      <div\n        key={n.name}\n        id={n.name}\n        className={`graph__node ${n.fake ? 'graph__node--fake' : ''}`}\n        style={{\n          width: n.css.width,\n          height: n.css.height,\n          transform: `translate(${n.css.translate.x}px, ${n.css.translate.y}px)`\n        }}\n        onMouseEnter={onMouseEnter}\n        onMouseLeave={onMouseLeave}\n        onMouseDown={onMouseDown}\n        onMouseMove={onMouseMove}\n        onMouseUp={onMouseUp}>\n        {n.node && <GraphNode item={n} />}\n\n        {n.fake === 1 && n.name}\n      </div>\n    );\n  });\n\n  // -------------------------------------------------------------------------------------------------------------------\n\n  return (\n    <div className='scene' id='scene' ref={scene}>\n      {/*<TransformLayer currentCoords={currentCoords.current}>{nodesJSX}</TransformLayer>*/}\n      {nodesJSX}\n    </div>\n  );\n};\n\nexport default Graph;\n","import React from 'react';\nimport './App.css';\nimport Graph from './Graph/Graph';\n\nfunction App() {\n\n  // @ts-ignore\n  const data = window.GRAPH_DATA;\n\n  return (\n    <div className=\"App\">\n      <Graph data={data}/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}